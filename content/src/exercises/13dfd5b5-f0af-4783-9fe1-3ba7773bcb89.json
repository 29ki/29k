{
  "sv": {
    "liveDuration": 30,
    "slides": [
      {
        "type": "host",
        "hostNotes": [
          {
            "text": "Välkommen. Jag heter X och vi kommer att jobba tillsammans i ungefär 30 minuter med självmedkänsla.\n\nVi kommer att lyssna på en ljudövning tillsammans, reflektera en stund för oss själva och sedan finns det möjlighet att dela sina erfarenheter."
          },
          {
            "text": "Vi börjar med en mini-check-in. Hur känner du dig just nu? Svara gärna med två-tre ord. X, skulle du vilja börja?\n\n> Låt alla deltagare, inklusive dig själv, checka in en och en. \n\nTack för att ni checkade in. Då kör vi igång."
          }
        ]
      },
      {
        "type": "content",
        "hostNotes": [
          {
            "text": "Hitta en bekväm position. Jag startar ljudövningen så möts vi här igen efteråt.\n\n> Tryck på play för att starta ljudövningen"
          }
        ],
        "content": {
          "lottie": {
            "subtitles": "https://res.cloudinary.com/cupcake-29k/raw/upload/q_auto,t_global/v1716209885/SRT%20(captions)%20files/Compassionate_intention_swe_f1bw0a.srt",
            "audio": "https://res.cloudinary.com/cupcake-29k/video/upload/v1716209848/Audio/Compassionate_intention_swe_qazugp.mp3",
            "durationTimer": true,
            "source": "https://res.cloudinary.com/cupcake-29k/raw/upload/t_card_image/v1676977421/Lottie/audio_meditation_default_black_default_omemwt.json"
          }
        }
      },
      {
        "type": "reflection",
        "hostNotes": [
          {
            "text": "Nästa steg är att tyst reflektera i en minut.\n\nHur vill du använda dig av självmedkänsla?"
          },
          {
            "text": "Om du vill kan du skriva ner dina funderingar på ett papper, eller bara tänka fritt. Det finns inga svar som är rätt eller fel här – vad som än dyker upp är okej.\n\n> Tryck på play för att starta timern.\n\nDå har det gått en minut och det är dags att gå vidare."
          }
        ],
        "content": {
          "lottie": {
            "durationTimer": true,
            "duration": 60,
            "source": "https://res.cloudinary.com/cupcake-29k/raw/upload/t_card_image/v1676642915/Lottie/default_1min_black_rosi2l.json"
          },
          "heading": "Hur vill du använda dig av självmedkänsla?"
        }
      },
      {
        "type": "sharing",
        "hostNotes": [
          {
            "text": "Det här steget handlar om att dela med sig av sin upplevelse och lyssna på andras. Vi har tre regler:\n\n1. **Det som sägs här, stannar här.**\n2. **Allt som behövs är att vi lyssnar på varandra.** Inget fixande, ingen rådgivning eller annan hjälp behövs. Vi är bara här för att utforska våra egna och andras upplevelser."
          },
          {
            "text": "3. **Allt som händer på insidan är okej.** Ilska, kärlek, smärta, glädje. Vad som än dyker upp, det finns inget rätt eller fel. Det bara är som det är.\n\nDet finns en timer på två minuter att hålla sig efter på ett ungefär. Om du inte vill dela med dig är det bara att säga 'pass'."
          },
          {
            "text": "Vem vill börja?\n\n> Låt alla, eller så många som det finns tid för, dela en efter en. Tryck på play för att starta timern. Starta om för varje person.\n\nTack så mycket för att ni lyssnar och delar med er."
          }
        ],
        "id": "Sharing 1",
        "content": {
          "lottie": {
            "durationTimer": true,
            "duration": 120,
            "source": "https://res.cloudinary.com/cupcake-29k/raw/upload/t_card_image/v1676639253/Lottie/default_2min_black_o6egey.json"
          },
          "heading": "Hur vill du använda dig av självmedkänsla?"
        }
      },
      {
        "type": "host",
        "hostNotes": [
          {
            "text": "Bra jobbat. Självmedkänsla handlar om att varsamt vara vänliga och mjuka mot oss själva. Om du vill så finns det ett uppdrag för dig:\n\nStäll in en påminnelse vid en valfri tidpunkt under de kommande fem dagarna. När du får påminnelsen – stanna upp och tänk på dina behov för ett ögonblick, och gör sedan något snällt för dig själv, just där och då.\n"
          },
          {
            "text": "Innan vi avslutar så gör vi en mini-utcheckning.\nHur känner du dig nu? Har något ändrats? Svara med två-tre ord.\n\nVem vill börja?"
          },
          {
            "text": "> Låt alla checka ut en efter en.\n\nTack så mycket för era utcheckningar, och för att ni deltog i den här sessionen.\n\n> Avsluta sessionen för att skicka deltagarna till exit-upplevelsen."
          }
        ]
      },
      {
        "type": "instruction",
        "content": {
          "text": "Självmedkänsla handlar om att varsamt vara vänliga och mjuka mot oss själva. \n\nOm du vill så finns det ett uppdrag för dig:\n\nStäll in en påminnelse vid en valfri tidpunkt under de kommande fem dagarna. När du får påminnelsen – stanna upp och tänk på dina behov för ett ögonblick, och gör sedan något snällt för dig själv, just där och då.",
          "image": {
            "source": "https://res.cloudinary.com/cupcake-29k/image/upload/q_auto,t_global/v1711547457/Images/card_Compassionate_intention_ub0tzl.png"
          },
          "heading": "Bra jobbat"
        }
      }
    ],
    "theme": {
      "textColor": "#2E2E2E",
      "backgroundColor": "#55e069"
    },
    "hidden": false,
    "locked": false,
    "name": "Omtänksam intention",
    "live": true,
    "published": true,
    "asyncDuration": 9,
    "card": {
      "image": {
        "source": "https://res.cloudinary.com/cupcake-29k/image/upload/t_card_image/v1711547457/Images/card_Compassionate_intention_ub0tzl.png"
      }
    },
    "coCreators": [
      {
        "name": "Jenny Rickardsson, manus",
        "url": "https://www.linkedin.com/in/jenny-rickardson-6770a959/?originalSubdomain=se",
        "image": "https://res.cloudinary.com/cupcake-29k/image/upload/t_cocreator_image/v1665413228/Contributors/Jenny%20Rickardsson.jpg"
      },
      {
        "name": "Kristin Neff & Chris Germer, forskning",
        "url": "https://centerformsc.org/about/",
        "image": "https://res.cloudinary.com/cupcake-29k/image/upload/t_cocreator_image/v1697723039/Images/Germer%2C%20Neff.png"
      },
      {
        "name": "Lisa Lööf, röst",
        "url": "https://www.linkedin.com/in/lisaloof/",
        "image": "https://res.cloudinary.com/cupcake-29k/image/upload/t_cocreator_image/v1665413154/Contributors/Lisa%20L%C3%B6%C3%B6f.jpg"
      },
      {
        "name": "tk87, artwork",
        "url": "https://openprocessing.org/user/332136?view=sketches&o=1",
        "image": "https://res.cloudinary.com/cupcake-29k/image/upload/t_cocreator_image/v1713964400/Images/user332136_oyt2dt.jpg"
      }
    ],
    "introPortal": {
      "textColor": "#F9F8F4",
      "hostNotes": [
        {
          "text": "> Starta sessionen när ni är redo"
        }
      ],
      "videoLoop": {
        "p5JsScript": {
          "lang": "javascript",
          "code": "let H;\nlet W;\n\nlet G;\n\nlet SEED;\n\nlet flocks = [];\nlet ID, ID2;\nlet PRE_COL;\n\nlet POSX = [];\nlet POSY = [];\nlet C1 = 7;\nlet C4 = 100;\nlet C02;\nlet C2 = 4;\n\nlet FRAME1 = 360; //360;\nlet FRAME2 = 180;\nlet FRAME3 = 180;\nlet FRAME4 = 90;\n\nlet BACK_COL;\n\nlet T_TYPE = [];\nlet T_SPEED = [];\nlet T_RAD = [];\nlet T_MCOH = [];\nlet T_ICOH = [];\n\nlet T_RED = [];\nlet T_GREEN = [];\nlet T_BLUE = [];\n\nlet OS_X = [];\nlet OS_Y = [];\n\nfunction setup() {\n  W = windowWidth;\n  H = windowHeight;\n  createCanvas(W, H);\n  G = createGraphics(W, H);\n\n  //SEED = fxrand()*998244353;\n  SEED = random() * 998244353;\n\n  randomSeed(SEED);\n  noiseSeed(SEED);\n\n  G.rectMode(CENTER);\n  G.noStroke();\n  let bsel = int(random(2));\n  let bcol = [60, 200];\n  BACK_COL = bcol[bsel];\n\n\n  ID = [0, 1, 2];\n  ID2 = [0, 1, 2];\n  shuffle(ID, true);\n  shuffle(ID2, true);\n\n  PRE_COL = [random(75) + 70, random(75) + 35, random(35)];\n\n  for (let i = 0; i < C1; i++) {\n    POSX[i] = random(-W / 3, W / 3) + W / 2;\n    POSY[i] = random(-H / 4, H / 2) + H / 2;\n  }\n\n  let cycle1 = [120, 180, 360];\n  let csel = int(random(3));\n  let mx_coh = 1.0; //random(1.3, 1.5);\n  flocks.push(new Flock());\n  for (let i = 0; i < 500; ++i) {\n    flocks[0].add(\n      new Particle(\n        0,\n        0,\n        7.5,\n        150,\n        FRAME1,\n        cycle1[csel],\n        0.0,\n        mx_coh,\n        10,\n        int(random(C1)),\n      ),\n    );\n  }\n\n  T_RED = [];\n  T_GREEN = [];\n  T_BLUE = [];\n  for (let i = 0; i < C4; ++i) {\n    POSX[i] = random(-W / 2, W / 2) + W / 2;\n    POSY[i] = random(-H / 2, H / 2) + H / 2;\n    T_RED.push(random(30, 220));\n    T_GREEN.push(random(30, 220));\n    T_BLUE.push(random(30, 220));\n  }\n\n  let cycle4 = [45, 90];\n  mx_coh = 0.6;\n  flocks.push(new Flock());\n  for (let i = 0; i < 500; ++i) {\n    let csel4 = int(random(2));\n    flocks[1].add(\n      new Particle(\n        2,\n        1,\n        1.5,\n        20,\n        FRAME4,\n        cycle4[csel4],\n        0.0,\n        mx_coh,\n        10,\n        int(random(C4)),\n      ),\n    );\n  }\n\n  let mode = 1;\n  if (mode == 1) {\n    for (let ii = 0; ii < 2; ++ii) {\n      let X2 = [];\n      let n_tree = int(random(6, 10));\n      let fdiv = 2;\n      if (ii == 1) {\n        n_tree = int((n_tree / 3) * 2);\n        fdiv = 2.5;\n      }\n      for (let i = 0; i < n_tree; ++i) {\n        X2.push(random(-W / fdiv, W / fdiv));\n      }\n      C02 = n_tree;\n      for (let i = 0; i < C02; ++i) {\n        POSX[i] = X2[i] + W / 2 + random(-15, 15);\n        POSY[i] = random(-H / 2, -H / 3) + H / 3 + (H / 6) * ii; //top\n      }\n\n      T_TYPE = [];\n      T_SPEED = [];\n      T_RAD = [];\n      T_MCOH = [];\n      T_ICOH = [];\n\n      T_RED = [];\n      T_GREEN = [];\n      T_BLUE = [];\n\n      OS_X = [];\n      OS_Y = [];\n\n      for (let i = 0; i < C02; ++i) {\n        T_TYPE.push(0); //int(random(2)));\n        T_RED.push(random(50, 200));\n        T_GREEN.push(random(50, 200));\n        T_BLUE.push(random(50, 200));\n\n        OS_X.push(random(-100, 100));\n        OS_Y.push(random(H / 3));\n      }\n\n      FRAME2 = 180;\n      let cycle1 = [180];\n      let csel1 = int(random(1));\n      mx_coh = 3;\n      flocks.push(new Flock());\n      for (let i = 0; i < 300; ++i) {\n        let speed = random(6, 12);\n        flocks[ii * 2 + 2].add(\n          new Particle(\n            1,\n            1,\n            speed,\n            20,\n            FRAME2,\n            cycle1[csel1],\n            0.5,\n            mx_coh,\n            ii * 10 + 15,\n            int(random(C02)),\n          ),\n        );\n      }\n\n      T_SPEED = [2.5, 2];\n      T_MCOH = [0.3, 1.0];\n      T_ICOH = [0.0, 0.0];\n      T_RAD = [20, 20];\n\n      FRAME3 = 180;\n      let cycle2 = [90, 180];\n\n      flocks.push(new Flock());\n      for (let i = 0; i < 500; ++i) {\n        let csel2 = int(random(2));\n        let tp_sel = int(random(C02));\n        let tp = T_TYPE[tp_sel];\n        flocks[ii * 2 + 3].add(\n          new Particle(\n            1,\n            2,\n            T_SPEED[tp],\n            T_RAD[tp],\n            FRAME3,\n            cycle2[csel2],\n            T_ICOH[tp],\n            T_MCOH[tp],\n            ii * 10 + 5,\n            tp_sel,\n          ),\n        );\n      }\n    }\n  }\n\n  //let X2 = random(-W/2, W/2) + W/2;\n  let Y2 = random(-H / 4, H / 2) + H / 2;\n  for (let i = 0; i < C2; ++i) {\n    POSX[i] = random(-W / 2, W / 2) + W / 2;\n    POSY[i] = random(-H / 4, H / 4) + Y2;\n  }\n}\n\nfunction draw() {\n  blendMode(BLEND);\n  background(BACK_COL);\n\n  if (frameCount < FRAME1) {\n    flocks[0].run();\n  } else if (frameCount < FRAME1 + FRAME4) {\n    flocks[1].run();\n  } else if (frameCount < FRAME1 + FRAME4 + FRAME2) {\n    flocks[2].run();\n  } else if (frameCount < FRAME1 + FRAME4 + FRAME2 + FRAME3) {\n    flocks[3].run();\n  } else if (frameCount < FRAME1 + FRAME4 + FRAME2 * 2 + FRAME3) {\n    flocks[4].run();\n  } else if (frameCount < FRAME1 + FRAME4 + FRAME2 * 2 + FRAME3 * 2) {\n    flocks[5].run();\n  }\n\n  image(G, 0, 0, width, height, 0, 0, W, H);\n}\n\nclass Flock {\n  particles;\n\n  constructor() {\n    this.particles = [];\n  }\n\n  add(particle) {\n    this.particles.push(particle);\n  }\n\n  run() {\n    this.update();\n    this.display();\n  }\n\n  update() {\n    for (let i = 0; i < this.particles.length; ++i) {\n      this.particles[i].update(this.particles);\n    }\n  }\n\n  display() {\n    for (let i = 0; i < this.particles.length; ++i) {\n      this.particles[i].display();\n    }\n  }\n}\n\nclass Particle {\n  acceleration;\n  velocity;\n  position;\n  radius;\n  max_r;\n  color;\n  col_sep;\n  maxforce = 1.0;\n  maxspeed = 2.5;\n  minspeed = 0.001;\n  mode;\n  base;\n  ali_f = 0.0;\n  coh_f = 0.0;\n  max_coh;\n  alpha;\n  fcnt;\n  cycle;\n  lcnt;\n  fin;\n\n  constructor(mode, base, speed, max_r, lcnt, cycle, coh, mxcoh, alpha, sel) {\n    this.acceleration = createVector(0, 0);\n\n    this.mode = mode;\n    this.base = base;\n    let offset_x;\n    let offset_y;\n\n    this.radius = 1;\n    this.alpha = alpha;\n\n    //let sel;\n    if (this.base == 0) {\n      this.maxspeed = speed;\n      this.col_sep = 0.5;\n      this.position = createVector(POSX[sel], POSY[sel]);\n      this.max_r = max_r;\n      this.velocity = createVector(random(-1, 1), random(-1, 1));\n    }\n    if (this.mode == 1) {\n      if (this.base == 1) {\n        offset_y = H / 2;\n        this.maxspeed = speed;\n        this.col_sep = 0.5;\n        this.position = createVector(\n          POSX[sel] + random(-5, 5),\n          POSY[sel] + offset_y,\n        );\n        this.max_r = max_r;\n        this.velocity = createVector(random(-1, 1), random(0.5, 1)); //;createVector(random(-1, 1), random(-1, 1));\n      } else if (this.base == 2) {\n        if (T_TYPE[sel] == 0) {\n          offset_y = random(H / 2);\n          this.maxspeed = speed * (offset_y / H) * (offset_y / H) * 5;\n          this.col_sep = 0.5;\n          this.position = createVector(POSX[sel], max(5, POSY[sel] + offset_y));\n          this.max_r = max_r + (offset_y / H) * 50;\n          this.velocity = createVector(random(-1, 1), random(0.1, 1));\n        } else {\n          offset_x = OS_X[sel];\n          offset_y = OS_Y[sel];\n          this.maxspeed = speed;\n          this.col_sep = 0.5;\n          this.position = createVector(\n            POSX[sel] + offset_x,\n            POSY[sel] + offset_y,\n          );\n          this.max_r = max_r;\n          this.velocity = createVector(random(-1, 1), random(-1, 1));\n        }\n      }\n    } else if (this.mode == 2) {\n      let ratio = POSY[sel] / H + 0.2;\n      this.maxspeed = speed * 1.2 * ratio;\n      this.radius = this.radius * 1.2 * ratio;\n      this.alpha = this.alpha * 1.2 * ratio;\n      if (this.base == 1) {\n        this.col_sep = 0.5;\n        this.position = createVector(POSX[sel], POSY[sel]);\n        this.max_r = max_r;\n        this.velocity = createVector(random(-1, 1), random(-1, 1));\n      }\n      // else if(this.base == 2){\n      //     this.col_sep = 0.5;\n      //     this.position = createVector(POSX[sel], POSY[sel]);\n      //     this.max_r = max_r;\n      //     this.velocity = createVector(random(-1, 1), random(-1, 1));\n      // }\n    }\n\n    //color\n    if (this.base == 0) {\n      this.color = createVector(\n        max(0, PRE_COL[ID[0]] + random(-50, 30)),\n        max(0, PRE_COL[ID[1]] + random(-50, 30)),\n        max(0, PRE_COL[ID[2]] + random(-50, 30)),\n      );\n    }\n    if (this.mode == 1) {\n      if (this.base == 1) {\n        this.color = createVector(\n          min(\n            255,\n            max(0, 200 - PRE_COL[ID[0]] + T_RED[sel] / 6 + random(-100, 0)),\n          ),\n          min(\n            255,\n            max(0, 200 - PRE_COL[ID[1]] + T_GREEN[sel] / 6 + random(-100, 0)),\n          ),\n          min(\n            255,\n            max(0, 200 - PRE_COL[ID[2]] + T_BLUE[sel] / 6 + random(-100, 0)),\n          ),\n        );\n      } else if (this.base == 2) {\n        this.color = createVector(\n          min(255, max(0, T_RED[sel] + random(-50, 50))),\n          min(255, max(0, T_GREEN[sel] + random(-50, 50))),\n          min(255, max(0, T_BLUE[sel] + random(-50, 50))),\n        );\n      }\n    } else if (this.mode == 2) {\n      if (this.base == 1) {\n        this.color = createVector(\n          min(255, max(0, T_RED[sel] + random(-30, 30))),\n          min(255, max(0, T_GREEN[sel] + random(-30, 30))),\n          min(255, max(0, T_BLUE[sel] + random(-30, 30))),\n        );\n      } else if (this.base == 2) {\n        this.color = createVector(\n          max(100, min(255, PRE_COL[ID[0]] + random(0, 100))),\n          max(100, min(255, PRE_COL[ID[1]] + random(0, 100))),\n          max(100, min(255, PRE_COL[ID[2]] + random(0, 100))),\n        );\n      }\n    }\n\n    this.ali_f = coh;\n    this.coh_f = coh;\n    this.max_coh = mxcoh;\n\n    this.fcnt = 0;\n    this.cycle = cycle;\n    this.fin = false;\n    this.lcnt = lcnt;\n  }\n\n  applyForce(force) {\n    this.acceleration.add(force);\n  }\n\n  inner_update(particles) {\n    let sep = this.separate(particles);\n    let ali = this.align(particles);\n    let coh = this.cohesion(particles);\n\n    sep.mult(1.5);\n    ali.mult(this.ali_f);\n    coh.mult(this.coh_f);\n\n    this.applyForce(sep);\n    this.applyForce(ali);\n    this.applyForce(coh);\n  }\n\n  update(particles) {\n    if (this.fcnt >= this.lcnt) {\n      this.fin = true;\n    }\n    if (this.fin) {\n      return;\n    }\n    this.inner_update(particles);\n\n    this.velocity.add(this.acceleration);\n    if (this.base == 0) {\n      if (this.fcnt < this.lcnt / 2) {\n        this.velocity.add(createVector(0, -0.1));\n      }\n    } else if (this.mode == 1 && this.base == 1) {\n      this.velocity.add(createVector(0.0, 0.2));\n    } else {\n      if (this.fcnt < this.lcnt / 2) {\n        this.velocity.add(createVector(-0.0, 0));\n      }\n    }\n\n    this.velocity.limit(this.maxspeed);\n    this.position.add(this.velocity);\n    this.border();\n    this.acceleration.mult(0);\n\n    this.radius = abs(sin((this.fcnt / this.cycle) * PI)) * this.max_r + 1;\n\n    if (this.base == 0) {\n      this.ali_f = min(1.0, this.ali_f + 0.05);\n      this.coh_f = min(this.max_coh, this.coh_f + 0.05);\n    } else if (this.mode == 1 && this.base == 1) {\n      this.ali_f = min(1.5, this.ali_f + 0.03);\n      this.coh_f = min(this.max_coh, this.coh_f + 0.05);\n    } else {\n      this.ali_f = min(0.7, this.ali_f + 0.1);\n      this.coh_f = min(this.max_coh, this.coh_f + 0.05);\n    }\n\n    if (this.fcnt < this.lcnt) {\n      this.fcnt += 1;\n    }\n  }\n\n  border() {\n    //if(this.base != 1 || this.mode != 1){\n    if (this.position.x > W) {\n      this.position.x -= W;\n    } else if (this.position.x < 0) {\n      this.position.x += W;\n    }\n    if ((this.base != 1 || this.mode != 1) && this.mode != 2) {\n      if (this.position.y > H) {\n        this.position.y -= H;\n      } else if (this.position.y < 0) {\n        this.position.y += H;\n      }\n    }\n  }\n\n  seek(target) {\n    let v = p5.Vector.sub(target, this.position);\n    v.normalize();\n    v.mult(this.maxspeed);\n    v.sub(this.velocity);\n    v.limit(this.maxforce);\n    return v;\n  }\n\n  separate(particles) {\n    let inter_range = 128.0;\n    let v = createVector(0, 0, 0);\n    for (let i = 0; i < particles.length; i++) {\n      let d = p5.Vector.dist(this.position, particles[i].position);\n      if (d <= 0) continue;\n\n      let col_diff = p5.Vector.sub(this.color, particles[i].color).mag() - 110;\n      if (d < inter_range + col_diff * this.col_sep) {\n        let diff = p5.Vector.sub(this.position, particles[i].position);\n        diff.normalize();\n        diff.div(d);\n        v.add(diff);\n      }\n    }\n\n    if (v.mag() > 0) {\n      v.normalize();\n      v.mult(this.maxspeed);\n      v.sub(this.velocity);\n      v.limit(this.maxforce);\n    }\n\n    return v;\n  }\n\n  align(particles) {\n    let inter_range = 128.0;\n    let v = createVector(0, 0, 0);\n    let count = 0;\n    for (let i = 0; i < particles.length; i++) {\n      let d = p5.Vector.dist(this.position, particles[i].position);\n      //let col_diff = abs(this.color - particles[i].color) - 128;\n      let col_diff = p5.Vector.sub(this.color, particles[i].color).mag() - 110;\n      if (d > 0 && d < inter_range - col_diff * this.col_sep) {\n        v.add(particles[i].velocity);\n        count++;\n      }\n    }\n    if (count > 0) {\n      v.div(count);\n      v.normalize();\n      v.mult(this.maxspeed);\n      v.sub(this.velocity);\n      v.limit(this.maxforce);\n      return v;\n    } else {\n      return createVector(0, 0, 0);\n    }\n  }\n\n  cohesion(particles) {\n    let neighbor_range = 128.0;\n    let v = createVector(0, 0, 0);\n    let count = 0;\n    for (let i = 0; i < particles.length; i++) {\n      let d = p5.Vector.dist(this.position, particles[i].position);\n\n      let col_diff = p5.Vector.sub(this.color, particles[i].color).mag() - 110;\n      if (d > 0 && d < neighbor_range - col_diff * this.col_sep) {\n        v.add(particles[i].position);\n\n        count++;\n      }\n    }\n    if (count > 0) {\n      v.div(count);\n      return this.seek(v);\n    } else {\n      return createVector(0, 0, 0);\n    }\n  }\n\n  display() {\n    if (this.fin) {\n      return;\n    }\n    let ratio = 1.0;\n    //if (this.base == 0){\n    //ratio = (H - this.position.y) / H * 1. + random(1.0);\n    ratio = 0.8 + random(0.5);\n    //}\n    if (this.base == 0) {\n      ratio = ratio * (3.0 - 3 * sqrt(this.position.y / H) * random(0.8, 1.2));\n    }\n    if (this.mode == 1 && this.base == 2) {\n      ratio = ratio + random(-0.2, 1);\n    }\n    G.strokeWeight(this.radius);\n    G.stroke(\n      this.color.x * ratio,\n      this.color.y * ratio,\n      this.color.z * ratio,\n      this.alpha,\n    );\n    G.point(this.position.x, this.position.y);\n  }\n}"
        },
        "audio": "https://res.cloudinary.com/cupcake-29k/video/upload/v1712905234/Audio/portal_audio_compassionate_intention_uniaec.mp3"
      }
    },
    "tags": ["db34d82a-4c48-4ddd-9de5-f562d8aa1bc9"],
    "link": "https://aware.29k.org/compassionateintention",
    "id": "13dfd5b5-f0af-4783-9fe1-3ba7773bcb89",
    "async": true,
    "description": "Lär dig om självmedkänsla och hur du kan använda det i ditt liv och din vardag. "
  },
  "en": {
    "liveDuration": 30,
    "slides": [
      {
        "type": "host",
        "hostNotes": [
          {
            "text": "Welcome. I am X and today we will work for around 30 minutes on self-compassion.\n\nWe’ll be doing an audio exercise, followed by time for reflection and sharing with each other."
          },
          {
            "text": "Let’s start with a mini check-in. How are you feeling right now? Please answer in two-three words. X, would you like to start?\n\n> Let everyone in the session, including yourself, check in one by one.\n\nThank you all for checking in. Let’s get started."
          }
        ]
      },
      {
        "type": "content",
        "hostNotes": [
          {
            "text": "Find a comfortable position. I will start the audio exercise and we'll meet back here afterwards. \n\n> Tap play to start the audio exercise"
          }
        ],
        "content": {
          "lottie": {
            "subtitles": "https://res.cloudinary.com/cupcake-29k/raw/upload/v1758025634/SRT%20%28captions%29%20files/Compassionate_intention_Oscar_ccp6k2.srt",
            "audio": "https://res.cloudinary.com/cupcake-29k/video/upload/v1758025702/Audio/Compassionate_intention_Oscar_v1oc1g.mp3",
            "durationTimer": true,
            "source": "https://res.cloudinary.com/cupcake-29k/raw/upload/t_card_image/v1676977421/Lottie/audio_meditation_default_black_default_omemwt.json"
          }
        }
      },
      {
        "type": "reflection",
        "hostNotes": [
          {
            "text": "Now we’ll take 1 minute to reflect on our own.\n\nWhere do you want to go with self-compassion?"
          },
          {
            "text": "You can take notes on a piece of paper or just mental notes in your head. And there is no right or wrong here, our answers are our own. 1 minute starting now.\n\n> Press play to start the timer.\n\nThat’s 1 minute and it’s time to move on."
          }
        ],
        "content": {
          "lottie": {
            "durationTimer": true,
            "duration": 60,
            "source": "https://res.cloudinary.com/cupcake-29k/raw/upload/t_card_image/v1676642915/Lottie/default_1min_black_rosi2l.json"
          },
          "heading": "Where do you want to go with self-compassion?"
        }
      },
      {
        "type": "sharing",
        "hostNotes": [
          {
            "text": "Now we are getting into the sharing part. We have three rules for sharing:\n\n1. **What is said in here, stays in here.**\n2. **All you need to do is listen.** There is no fixing, helping or advice-giving needed. We are just showing up and exploring what ourselves and others are going through."
          },
          {
            "text": "3. **Everything on the inside is okay.** Anger, love, hatred, sadness. Whatever shows up. No wrongs, no rights. It is what it is.\n\nThere will be a timer set for 2 minutes as an indicator. If you don’t want to share you can always say ‘pass’."
          },
          {
            "text": "Who would like to start?\n\n> Let everyone (or as many as you got time for) share one by one. Press play to start the timer. Re-start for each new sharing.\n\nThank you so much everyone."
          }
        ],
        "id": "Sharing 1",
        "content": {
          "lottie": {
            "durationTimer": true,
            "duration": 120,
            "source": "https://res.cloudinary.com/cupcake-29k/raw/upload/t_card_image/v1676639253/Lottie/default_2min_black_o6egey.json"
          },
          "heading": "Where do you want to go with self-compassion?"
        }
      },
      {
        "type": "host",
        "hostNotes": [
          {
            "text": "Well done. Self-compassion is a gentle art, about being kind and gentle with ourselves. If you’re up for it, you can continue with this mission:\n\nSet a reminder at a random time of the day for five days. When it goes off – stop and consider your needs for a moment, and do something kind to yourself before moving on."
          },
          {
            "text": "Before we leave this space let’s do a mini check-out. \n\nHow are you feeling right now? Has anything shifted? Please answer in two-three words."
          },
          {
            "text": "Who would like to start?\n\n> Let everyone in the session check out one by one.\n\nThank you all for checking out and for joining this session today.\n\n> Finish session to send everyone off to the exit experience."
          }
        ]
      },
      {
        "type": "instruction",
        "content": {
          "text": "Self-compassion is a gentle art, about being kind and gentle with ourselves. \n\nIf you’re up for it, you can continue with a mission:\n\nSet a reminder at a random time of the day for five days. When it goes off – stop and consider your needs for a moment, and do something kind to yourself before moving on.",
          "image": {
            "source": "https://res.cloudinary.com/cupcake-29k/image/upload/q_auto,t_global/v1711547457/Images/card_Compassionate_intention_ub0tzl.png"
          },
          "heading": "Well done"
        }
      }
    ],
    "theme": {
      "textColor": "#2E2E2E",
      "backgroundColor": "#55e069"
    },
    "hidden": false,
    "locked": false,
    "name": "Compassionate intention",
    "live": true,
    "published": true,
    "asyncDuration": 9,
    "card": {
      "image": {
        "source": "https://res.cloudinary.com/cupcake-29k/image/upload/t_card_image/v1711547457/Images/card_Compassionate_intention_ub0tzl.png"
      }
    },
    "coCreators": [
      {
        "name": "Jenny Rickardsson, script, editor",
        "url": "https://www.linkedin.com/in/jenny-rickardson-6770a959/?originalSubdomain=se",
        "image": "https://res.cloudinary.com/cupcake-29k/image/upload/t_cocreator_image/v1665413228/Contributors/Jenny%20Rickardsson.jpg"
      },
      {
        "name": "Kristin Neff & Chris Germer, original research",
        "url": "https://centerformsc.org/about/",
        "image": "https://res.cloudinary.com/cupcake-29k/image/upload/t_cocreator_image/v1697723039/Images/Germer%2C%20Neff.png"
      },
      {
        "name": "Oscar Kopljar, voice",
        "url": "www.29k.org",
        "image": "https://res.cloudinary.com/cupcake-29k/image/upload/t_cocreator_image/v1674554605/Images/thumb_content_be_kind_to_yourself_hn38hz.png"
      },
      {
        "name": "tk87, artwork",
        "url": "https://openprocessing.org/user/332136?view=sketches&o=1",
        "image": "https://res.cloudinary.com/cupcake-29k/image/upload/t_cocreator_image/v1713964400/Images/user332136_oyt2dt.jpg"
      }
    ],
    "introPortal": {
      "textColor": "#F9F8F4",
      "hostNotes": [
        {
          "text": "> Start the session when you're ready to go"
        }
      ],
      "videoLoop": {
        "p5JsScript": {
          "lang": "javascript",
          "code": "let H;\nlet W;\n\nlet G;\n\nlet SEED;\n\nlet flocks = [];\nlet ID, ID2;\nlet PRE_COL;\n\nlet POSX = [];\nlet POSY = [];\nlet C1 = 7;\nlet C4 = 100;\nlet C02;\nlet C2 = 4;\n\nlet FRAME1 = 360; //360;\nlet FRAME2 = 180;\nlet FRAME3 = 180;\nlet FRAME4 = 90;\n\nlet BACK_COL;\n\nlet T_TYPE = [];\nlet T_SPEED = [];\nlet T_RAD = [];\nlet T_MCOH = [];\nlet T_ICOH = [];\n\nlet T_RED = [];\nlet T_GREEN = [];\nlet T_BLUE = [];\n\nlet OS_X = [];\nlet OS_Y = [];\n\nfunction setup() {\n  W = windowWidth;\n  H = windowHeight;\n  createCanvas(W, H);\n  G = createGraphics(W, H);\n\n  //SEED = fxrand()*998244353;\n  SEED = random() * 998244353;\n\n  randomSeed(SEED);\n  noiseSeed(SEED);\n\n  G.rectMode(CENTER);\n  G.noStroke();\n  let bsel = int(random(2));\n  let bcol = [60, 200];\n  BACK_COL = bcol[bsel];\n\n\n  ID = [0, 1, 2];\n  ID2 = [0, 1, 2];\n  shuffle(ID, true);\n  shuffle(ID2, true);\n\n  PRE_COL = [random(75) + 70, random(75) + 35, random(35)];\n\n  for (let i = 0; i < C1; i++) {\n    POSX[i] = random(-W / 3, W / 3) + W / 2;\n    POSY[i] = random(-H / 4, H / 2) + H / 2;\n  }\n\n  let cycle1 = [120, 180, 360];\n  let csel = int(random(3));\n  let mx_coh = 1.0; //random(1.3, 1.5);\n  flocks.push(new Flock());\n  for (let i = 0; i < 500; ++i) {\n    flocks[0].add(\n      new Particle(\n        0,\n        0,\n        7.5,\n        150,\n        FRAME1,\n        cycle1[csel],\n        0.0,\n        mx_coh,\n        10,\n        int(random(C1)),\n      ),\n    );\n  }\n\n  T_RED = [];\n  T_GREEN = [];\n  T_BLUE = [];\n  for (let i = 0; i < C4; ++i) {\n    POSX[i] = random(-W / 2, W / 2) + W / 2;\n    POSY[i] = random(-H / 2, H / 2) + H / 2;\n    T_RED.push(random(30, 220));\n    T_GREEN.push(random(30, 220));\n    T_BLUE.push(random(30, 220));\n  }\n\n  let cycle4 = [45, 90];\n  mx_coh = 0.6;\n  flocks.push(new Flock());\n  for (let i = 0; i < 500; ++i) {\n    let csel4 = int(random(2));\n    flocks[1].add(\n      new Particle(\n        2,\n        1,\n        1.5,\n        20,\n        FRAME4,\n        cycle4[csel4],\n        0.0,\n        mx_coh,\n        10,\n        int(random(C4)),\n      ),\n    );\n  }\n\n  let mode = 1;\n  if (mode == 1) {\n    for (let ii = 0; ii < 2; ++ii) {\n      let X2 = [];\n      let n_tree = int(random(6, 10));\n      let fdiv = 2;\n      if (ii == 1) {\n        n_tree = int((n_tree / 3) * 2);\n        fdiv = 2.5;\n      }\n      for (let i = 0; i < n_tree; ++i) {\n        X2.push(random(-W / fdiv, W / fdiv));\n      }\n      C02 = n_tree;\n      for (let i = 0; i < C02; ++i) {\n        POSX[i] = X2[i] + W / 2 + random(-15, 15);\n        POSY[i] = random(-H / 2, -H / 3) + H / 3 + (H / 6) * ii; //top\n      }\n\n      T_TYPE = [];\n      T_SPEED = [];\n      T_RAD = [];\n      T_MCOH = [];\n      T_ICOH = [];\n\n      T_RED = [];\n      T_GREEN = [];\n      T_BLUE = [];\n\n      OS_X = [];\n      OS_Y = [];\n\n      for (let i = 0; i < C02; ++i) {\n        T_TYPE.push(0); //int(random(2)));\n        T_RED.push(random(50, 200));\n        T_GREEN.push(random(50, 200));\n        T_BLUE.push(random(50, 200));\n\n        OS_X.push(random(-100, 100));\n        OS_Y.push(random(H / 3));\n      }\n\n      FRAME2 = 180;\n      let cycle1 = [180];\n      let csel1 = int(random(1));\n      mx_coh = 3;\n      flocks.push(new Flock());\n      for (let i = 0; i < 300; ++i) {\n        let speed = random(6, 12);\n        flocks[ii * 2 + 2].add(\n          new Particle(\n            1,\n            1,\n            speed,\n            20,\n            FRAME2,\n            cycle1[csel1],\n            0.5,\n            mx_coh,\n            ii * 10 + 15,\n            int(random(C02)),\n          ),\n        );\n      }\n\n      T_SPEED = [2.5, 2];\n      T_MCOH = [0.3, 1.0];\n      T_ICOH = [0.0, 0.0];\n      T_RAD = [20, 20];\n\n      FRAME3 = 180;\n      let cycle2 = [90, 180];\n\n      flocks.push(new Flock());\n      for (let i = 0; i < 500; ++i) {\n        let csel2 = int(random(2));\n        let tp_sel = int(random(C02));\n        let tp = T_TYPE[tp_sel];\n        flocks[ii * 2 + 3].add(\n          new Particle(\n            1,\n            2,\n            T_SPEED[tp],\n            T_RAD[tp],\n            FRAME3,\n            cycle2[csel2],\n            T_ICOH[tp],\n            T_MCOH[tp],\n            ii * 10 + 5,\n            tp_sel,\n          ),\n        );\n      }\n    }\n  }\n\n  //let X2 = random(-W/2, W/2) + W/2;\n  let Y2 = random(-H / 4, H / 2) + H / 2;\n  for (let i = 0; i < C2; ++i) {\n    POSX[i] = random(-W / 2, W / 2) + W / 2;\n    POSY[i] = random(-H / 4, H / 4) + Y2;\n  }\n}\n\nfunction draw() {\n  blendMode(BLEND);\n  background(BACK_COL);\n\n  if (frameCount < FRAME1) {\n    flocks[0].run();\n  } else if (frameCount < FRAME1 + FRAME4) {\n    flocks[1].run();\n  } else if (frameCount < FRAME1 + FRAME4 + FRAME2) {\n    flocks[2].run();\n  } else if (frameCount < FRAME1 + FRAME4 + FRAME2 + FRAME3) {\n    flocks[3].run();\n  } else if (frameCount < FRAME1 + FRAME4 + FRAME2 * 2 + FRAME3) {\n    flocks[4].run();\n  } else if (frameCount < FRAME1 + FRAME4 + FRAME2 * 2 + FRAME3 * 2) {\n    flocks[5].run();\n  }\n\n  image(G, 0, 0, width, height, 0, 0, W, H);\n}\n\nclass Flock {\n  particles;\n\n  constructor() {\n    this.particles = [];\n  }\n\n  add(particle) {\n    this.particles.push(particle);\n  }\n\n  run() {\n    this.update();\n    this.display();\n  }\n\n  update() {\n    for (let i = 0; i < this.particles.length; ++i) {\n      this.particles[i].update(this.particles);\n    }\n  }\n\n  display() {\n    for (let i = 0; i < this.particles.length; ++i) {\n      this.particles[i].display();\n    }\n  }\n}\n\nclass Particle {\n  acceleration;\n  velocity;\n  position;\n  radius;\n  max_r;\n  color;\n  col_sep;\n  maxforce = 1.0;\n  maxspeed = 2.5;\n  minspeed = 0.001;\n  mode;\n  base;\n  ali_f = 0.0;\n  coh_f = 0.0;\n  max_coh;\n  alpha;\n  fcnt;\n  cycle;\n  lcnt;\n  fin;\n\n  constructor(mode, base, speed, max_r, lcnt, cycle, coh, mxcoh, alpha, sel) {\n    this.acceleration = createVector(0, 0);\n\n    this.mode = mode;\n    this.base = base;\n    let offset_x;\n    let offset_y;\n\n    this.radius = 1;\n    this.alpha = alpha;\n\n    //let sel;\n    if (this.base == 0) {\n      this.maxspeed = speed;\n      this.col_sep = 0.5;\n      this.position = createVector(POSX[sel], POSY[sel]);\n      this.max_r = max_r;\n      this.velocity = createVector(random(-1, 1), random(-1, 1));\n    }\n    if (this.mode == 1) {\n      if (this.base == 1) {\n        offset_y = H / 2;\n        this.maxspeed = speed;\n        this.col_sep = 0.5;\n        this.position = createVector(\n          POSX[sel] + random(-5, 5),\n          POSY[sel] + offset_y,\n        );\n        this.max_r = max_r;\n        this.velocity = createVector(random(-1, 1), random(0.5, 1)); //;createVector(random(-1, 1), random(-1, 1));\n      } else if (this.base == 2) {\n        if (T_TYPE[sel] == 0) {\n          offset_y = random(H / 2);\n          this.maxspeed = speed * (offset_y / H) * (offset_y / H) * 5;\n          this.col_sep = 0.5;\n          this.position = createVector(POSX[sel], max(5, POSY[sel] + offset_y));\n          this.max_r = max_r + (offset_y / H) * 50;\n          this.velocity = createVector(random(-1, 1), random(0.1, 1));\n        } else {\n          offset_x = OS_X[sel];\n          offset_y = OS_Y[sel];\n          this.maxspeed = speed;\n          this.col_sep = 0.5;\n          this.position = createVector(\n            POSX[sel] + offset_x,\n            POSY[sel] + offset_y,\n          );\n          this.max_r = max_r;\n          this.velocity = createVector(random(-1, 1), random(-1, 1));\n        }\n      }\n    } else if (this.mode == 2) {\n      let ratio = POSY[sel] / H + 0.2;\n      this.maxspeed = speed * 1.2 * ratio;\n      this.radius = this.radius * 1.2 * ratio;\n      this.alpha = this.alpha * 1.2 * ratio;\n      if (this.base == 1) {\n        this.col_sep = 0.5;\n        this.position = createVector(POSX[sel], POSY[sel]);\n        this.max_r = max_r;\n        this.velocity = createVector(random(-1, 1), random(-1, 1));\n      }\n      // else if(this.base == 2){\n      //     this.col_sep = 0.5;\n      //     this.position = createVector(POSX[sel], POSY[sel]);\n      //     this.max_r = max_r;\n      //     this.velocity = createVector(random(-1, 1), random(-1, 1));\n      // }\n    }\n\n    //color\n    if (this.base == 0) {\n      this.color = createVector(\n        max(0, PRE_COL[ID[0]] + random(-50, 30)),\n        max(0, PRE_COL[ID[1]] + random(-50, 30)),\n        max(0, PRE_COL[ID[2]] + random(-50, 30)),\n      );\n    }\n    if (this.mode == 1) {\n      if (this.base == 1) {\n        this.color = createVector(\n          min(\n            255,\n            max(0, 200 - PRE_COL[ID[0]] + T_RED[sel] / 6 + random(-100, 0)),\n          ),\n          min(\n            255,\n            max(0, 200 - PRE_COL[ID[1]] + T_GREEN[sel] / 6 + random(-100, 0)),\n          ),\n          min(\n            255,\n            max(0, 200 - PRE_COL[ID[2]] + T_BLUE[sel] / 6 + random(-100, 0)),\n          ),\n        );\n      } else if (this.base == 2) {\n        this.color = createVector(\n          min(255, max(0, T_RED[sel] + random(-50, 50))),\n          min(255, max(0, T_GREEN[sel] + random(-50, 50))),\n          min(255, max(0, T_BLUE[sel] + random(-50, 50))),\n        );\n      }\n    } else if (this.mode == 2) {\n      if (this.base == 1) {\n        this.color = createVector(\n          min(255, max(0, T_RED[sel] + random(-30, 30))),\n          min(255, max(0, T_GREEN[sel] + random(-30, 30))),\n          min(255, max(0, T_BLUE[sel] + random(-30, 30))),\n        );\n      } else if (this.base == 2) {\n        this.color = createVector(\n          max(100, min(255, PRE_COL[ID[0]] + random(0, 100))),\n          max(100, min(255, PRE_COL[ID[1]] + random(0, 100))),\n          max(100, min(255, PRE_COL[ID[2]] + random(0, 100))),\n        );\n      }\n    }\n\n    this.ali_f = coh;\n    this.coh_f = coh;\n    this.max_coh = mxcoh;\n\n    this.fcnt = 0;\n    this.cycle = cycle;\n    this.fin = false;\n    this.lcnt = lcnt;\n  }\n\n  applyForce(force) {\n    this.acceleration.add(force);\n  }\n\n  inner_update(particles) {\n    let sep = this.separate(particles);\n    let ali = this.align(particles);\n    let coh = this.cohesion(particles);\n\n    sep.mult(1.5);\n    ali.mult(this.ali_f);\n    coh.mult(this.coh_f);\n\n    this.applyForce(sep);\n    this.applyForce(ali);\n    this.applyForce(coh);\n  }\n\n  update(particles) {\n    if (this.fcnt >= this.lcnt) {\n      this.fin = true;\n    }\n    if (this.fin) {\n      return;\n    }\n    this.inner_update(particles);\n\n    this.velocity.add(this.acceleration);\n    if (this.base == 0) {\n      if (this.fcnt < this.lcnt / 2) {\n        this.velocity.add(createVector(0, -0.1));\n      }\n    } else if (this.mode == 1 && this.base == 1) {\n      this.velocity.add(createVector(0.0, 0.2));\n    } else {\n      if (this.fcnt < this.lcnt / 2) {\n        this.velocity.add(createVector(-0.0, 0));\n      }\n    }\n\n    this.velocity.limit(this.maxspeed);\n    this.position.add(this.velocity);\n    this.border();\n    this.acceleration.mult(0);\n\n    this.radius = abs(sin((this.fcnt / this.cycle) * PI)) * this.max_r + 1;\n\n    if (this.base == 0) {\n      this.ali_f = min(1.0, this.ali_f + 0.05);\n      this.coh_f = min(this.max_coh, this.coh_f + 0.05);\n    } else if (this.mode == 1 && this.base == 1) {\n      this.ali_f = min(1.5, this.ali_f + 0.03);\n      this.coh_f = min(this.max_coh, this.coh_f + 0.05);\n    } else {\n      this.ali_f = min(0.7, this.ali_f + 0.1);\n      this.coh_f = min(this.max_coh, this.coh_f + 0.05);\n    }\n\n    if (this.fcnt < this.lcnt) {\n      this.fcnt += 1;\n    }\n  }\n\n  border() {\n    //if(this.base != 1 || this.mode != 1){\n    if (this.position.x > W) {\n      this.position.x -= W;\n    } else if (this.position.x < 0) {\n      this.position.x += W;\n    }\n    if ((this.base != 1 || this.mode != 1) && this.mode != 2) {\n      if (this.position.y > H) {\n        this.position.y -= H;\n      } else if (this.position.y < 0) {\n        this.position.y += H;\n      }\n    }\n  }\n\n  seek(target) {\n    let v = p5.Vector.sub(target, this.position);\n    v.normalize();\n    v.mult(this.maxspeed);\n    v.sub(this.velocity);\n    v.limit(this.maxforce);\n    return v;\n  }\n\n  separate(particles) {\n    let inter_range = 128.0;\n    let v = createVector(0, 0, 0);\n    for (let i = 0; i < particles.length; i++) {\n      let d = p5.Vector.dist(this.position, particles[i].position);\n      if (d <= 0) continue;\n\n      let col_diff = p5.Vector.sub(this.color, particles[i].color).mag() - 110;\n      if (d < inter_range + col_diff * this.col_sep) {\n        let diff = p5.Vector.sub(this.position, particles[i].position);\n        diff.normalize();\n        diff.div(d);\n        v.add(diff);\n      }\n    }\n\n    if (v.mag() > 0) {\n      v.normalize();\n      v.mult(this.maxspeed);\n      v.sub(this.velocity);\n      v.limit(this.maxforce);\n    }\n\n    return v;\n  }\n\n  align(particles) {\n    let inter_range = 128.0;\n    let v = createVector(0, 0, 0);\n    let count = 0;\n    for (let i = 0; i < particles.length; i++) {\n      let d = p5.Vector.dist(this.position, particles[i].position);\n      //let col_diff = abs(this.color - particles[i].color) - 128;\n      let col_diff = p5.Vector.sub(this.color, particles[i].color).mag() - 110;\n      if (d > 0 && d < inter_range - col_diff * this.col_sep) {\n        v.add(particles[i].velocity);\n        count++;\n      }\n    }\n    if (count > 0) {\n      v.div(count);\n      v.normalize();\n      v.mult(this.maxspeed);\n      v.sub(this.velocity);\n      v.limit(this.maxforce);\n      return v;\n    } else {\n      return createVector(0, 0, 0);\n    }\n  }\n\n  cohesion(particles) {\n    let neighbor_range = 128.0;\n    let v = createVector(0, 0, 0);\n    let count = 0;\n    for (let i = 0; i < particles.length; i++) {\n      let d = p5.Vector.dist(this.position, particles[i].position);\n\n      let col_diff = p5.Vector.sub(this.color, particles[i].color).mag() - 110;\n      if (d > 0 && d < neighbor_range - col_diff * this.col_sep) {\n        v.add(particles[i].position);\n\n        count++;\n      }\n    }\n    if (count > 0) {\n      v.div(count);\n      return this.seek(v);\n    } else {\n      return createVector(0, 0, 0);\n    }\n  }\n\n  display() {\n    if (this.fin) {\n      return;\n    }\n    let ratio = 1.0;\n    //if (this.base == 0){\n    //ratio = (H - this.position.y) / H * 1. + random(1.0);\n    ratio = 0.8 + random(0.5);\n    //}\n    if (this.base == 0) {\n      ratio = ratio * (3.0 - 3 * sqrt(this.position.y / H) * random(0.8, 1.2));\n    }\n    if (this.mode == 1 && this.base == 2) {\n      ratio = ratio + random(-0.2, 1);\n    }\n    G.strokeWeight(this.radius);\n    G.stroke(\n      this.color.x * ratio,\n      this.color.y * ratio,\n      this.color.z * ratio,\n      this.alpha,\n    );\n    G.point(this.position.x, this.position.y);\n  }\n}"
        },
        "audio": "https://res.cloudinary.com/cupcake-29k/video/upload/v1712905234/Audio/portal_audio_compassionate_intention_uniaec.mp3"
      }
    },
    "tags": ["db34d82a-4c48-4ddd-9de5-f562d8aa1bc9"],
    "link": "https://aware.29k.org/compassionateintention",
    "id": "13dfd5b5-f0af-4783-9fe1-3ba7773bcb89",
    "async": true,
    "description": "Learn about self-compassion, and how it can be useful in your life."
  },
  "pt-PT": {
    "liveDuration": 30,
    "slides": [
      {
        "type": "host",
        "hostNotes": [
          {
            "text": "Bem-vindos. Eu sou X e hoje vamos trabalhar cerca de 30 minutos em autocompaixão.\n\nVamos fazer um exercício de áudio, seguido de um tempo para reflexão e partilha entre nós."
          },
          {
            "text": "Vamos começar com um pequeno check-in. Como te estás a sentir? Por favor, responde em duas ou três palavras. X, queres começar?\n\n> Deixa que todos na sessão, incluindo-te a ti, façam o check-in individualmente.\n\nObrigada/o a todos por fazerem o check-in. Vamos começar."
          }
        ]
      },
      {
        "type": "content",
        "hostNotes": [
          {
            "text": "Encontra uma posição confortável e prepara-te para tomar algumas notas. Vou iniciar o exercício de áudio e voltamos aqui depois. \n\n> Carrega em play para iniciar o exercício."
          }
        ],
        "content": {
          "lottie": {
            "subtitles": "",
            "audio": "https://res.cloudinary.com/cupcake-29k/video/upload/v1727166578/FJN/Meditations/Florbela/Inten%C3%A7%C3%A3o_Compassiva_ox7ktn.mp3",
            "durationTimer": true,
            "source": "https://res.cloudinary.com/cupcake-29k/raw/upload/t_card_image/v1676977421/Lottie/audio_meditation_default_black_default_omemwt.json"
          }
        }
      },
      {
        "type": "reflection",
        "hostNotes": [
          {
            "text": "Agora vamos tirar 1 minuto para refletir individualmente.\n\nOnde queres chegar com a autocompaixão?"
          },
          {
            "text": "Podes tomar notas num pedaço de papel ou mentalmente. Não há certo ou errado, as nossas respostas são só nossas. 1 minuto a partir de agora.\n\n> Carrega em play para iniciar o cronómetro.\n\nPassou 1 minuto e é hora de avançar."
          }
        ],
        "content": {
          "lottie": {
            "durationTimer": true,
            "duration": 60,
            "source": "https://res.cloudinary.com/cupcake-29k/raw/upload/t_card_image/v1676642915/Lottie/default_1min_black_rosi2l.json"
          },
          "heading": "Onde queres chegar com a autocompaixão?"
        }
      },
      {
        "type": "sharing",
        "hostNotes": [
          {
            "text": "Agora passamos para a parte da partilha. Temos três regras para partilhar:\n\n1. **O que é dito aqui, fica aqui.**\n2. **Só precisas de ouvir.** Não é necessário corrigir, ajudar ou dar conselhos. Estamos apenas a explorar o que nós e os outros estão a passar."
          },
          {
            "text": "3. **Tudo o que sentires é válido.** Raiva, amor, ódio, tristeza. O que quer que surja. Não há certo ou errado. É o que é.\n\nHaverá um cronómetro de 2 minutos como indicador. Se não quiseres partilhar, pode sempre dizer 'passo'."
          },
          {
            "text": "Quem gostaria de começar?\n\n> Deixa que todos (ou os que houver tempo) partilhem individualmente. Carrega em play para iniciar o cronómetro. Reinicia para cada nova partilha.\n\nMuito obrigada/o a todos."
          }
        ],
        "id": "Sharing 1",
        "content": {
          "lottie": {
            "durationTimer": true,
            "duration": 120,
            "source": "https://res.cloudinary.com/cupcake-29k/raw/upload/t_card_image/v1676639253/Lottie/default_2min_black_o6egey.json"
          },
          "heading": "Onde queres chegar com a autocompaixão?"
        }
      },
      {
        "type": "host",
        "hostNotes": [
          {
            "text": "Muito bem. A autocompaixão é uma arte suave, trata-se de sermos gentis e cuidadosos connosco próprios. Se estiveres com disposição, podes continuar com esta missão:\n\nDefine um lembrete para uma hora aleatória do dia durante cinco dias. Quando o alarme tocar, pára, pensa nas tuas necessidades por um momento, e faz algo de bom por ti antes de seguires em frente."
          },
          {
            "text": "Antes de deixarmos este espaço, vamos fazer um pequeno check-out.\n\nComo te sentes agora? Alguma coisa mudou? Responde por favor em duas ou três palavras."
          },
          {
            "text": "Quem gostaria de começar?\n\n> Deixa que todos na sessão façam o check-out individualmente.\n\nObrigada/o a todos por fazerem o check-out final e por participarem nesta sessão de hoje.\n\n> Termina a sessão e envia todos para a experiência de saída."
          }
        ]
      },
      {
        "type": "instruction",
        "content": {
          "text": "A autocompaixão é uma arte suave, trata-se de sermos gentis e cuidadosos connosco próprios.\n\nSe estiveres com disposição, podes continuar com esta missão:\n\nDefine um lembrete para uma hora aleatória do dia durante cinco dias. Quando o alarme tocar, pára, pensa nas tuas necessidades por um momento, e faz algo de bom por ti antes de seguires em frente.",
          "image": {
            "source": "https://res.cloudinary.com/cupcake-29k/image/upload/q_auto,t_global/v1711547457/Images/card_Compassionate_intention_ub0tzl.png"
          },
          "heading": "Parabéns"
        }
      }
    ],
    "theme": {
      "textColor": "#2E2E2E",
      "backgroundColor": "#55e069"
    },
    "hidden": false,
    "locked": false,
    "name": "Intenção Compassiva",
    "live": true,
    "published": true,
    "asyncDuration": 9,
    "card": {
      "image": {
        "source": "https://res.cloudinary.com/cupcake-29k/image/upload/t_card_image/v1711547457/Images/card_Compassionate_intention_ub0tzl.png"
      }
    },
    "coCreators": [
      {
        "name": "Jenny Rickardsson, script, editor",
        "url": "https://www.linkedin.com/in/jenny-rickardson-6770a959/?originalSubdomain=se",
        "image": "https://res.cloudinary.com/cupcake-29k/image/upload/t_cocreator_image/v1665413228/Contributors/Jenny%20Rickardsson.jpg"
      },
      {
        "name": "Kristin Neff & Chris Germer, original research",
        "url": "https://centerformsc.org/about/",
        "image": "https://res.cloudinary.com/cupcake-29k/image/upload/t_cocreator_image/v1697723039/Images/Germer%2C%20Neff.png"
      },
      {
        "name": "Tabitha, AI-generated voice",
        "url": "https://www.descript.com/ai-voices",
        "image": "https://res.cloudinary.com/cupcake-29k/image/upload/t_cocreator_image/v1710239861/Contributors/descript_ps0olu.webp"
      },
      {
        "name": "tk87, artwork",
        "url": "https://openprocessing.org/user/332136?view=sketches&o=1",
        "image": "https://res.cloudinary.com/cupcake-29k/image/upload/t_cocreator_image/v1713964400/Images/user332136_oyt2dt.jpg"
      },
      {
        "name": "Florbela Silva, voz em Português",
        "url": "https://www.estudiodaalma.com",
        "image": "https://res.cloudinary.com/cupcake-29k/image/upload/t_cocreator_image/v1727943392/FJN/People/Florbela_Silva_bd0qx9.jpg"
      }
    ],
    "introPortal": {
      "textColor": "#F9F8F4",
      "hostNotes": [
        {
          "text": "> Inicia a sessão quando estiveres pronta/o para começar."
        }
      ],
      "videoLoop": {
        "p5JsScript": {
          "lang": "javascript",
          "code": "let H;\nlet W;\n\nlet G;\n\nlet SEED;\n\nlet flocks = [];\nlet ID, ID2;\nlet PRE_COL;\n\nlet POSX = [];\nlet POSY = [];\nlet C1 = 7;\nlet C4 = 100;\nlet C02;\nlet C2 = 4;\n\nlet FRAME1 = 360; //360;\nlet FRAME2 = 180;\nlet FRAME3 = 180;\nlet FRAME4 = 90;\n\nlet BACK_COL;\n\nlet T_TYPE = [];\nlet T_SPEED = [];\nlet T_RAD = [];\nlet T_MCOH = [];\nlet T_ICOH = [];\n\nlet T_RED = [];\nlet T_GREEN = [];\nlet T_BLUE = [];\n\nlet OS_X = [];\nlet OS_Y = [];\n\nfunction setup() {\n  W = windowWidth;\n  H = windowHeight;\n  createCanvas(W, H);\n  G = createGraphics(W, H);\n\n  //SEED = fxrand()*998244353;\n  SEED = random() * 998244353;\n\n  randomSeed(SEED);\n  noiseSeed(SEED);\n\n  G.rectMode(CENTER);\n  G.noStroke();\n  let bsel = int(random(2));\n  let bcol = [60, 200];\n  BACK_COL = bcol[bsel];\n\n\n  ID = [0, 1, 2];\n  ID2 = [0, 1, 2];\n  shuffle(ID, true);\n  shuffle(ID2, true);\n\n  PRE_COL = [random(75) + 70, random(75) + 35, random(35)];\n\n  for (let i = 0; i < C1; i++) {\n    POSX[i] = random(-W / 3, W / 3) + W / 2;\n    POSY[i] = random(-H / 4, H / 2) + H / 2;\n  }\n\n  let cycle1 = [120, 180, 360];\n  let csel = int(random(3));\n  let mx_coh = 1.0; //random(1.3, 1.5);\n  flocks.push(new Flock());\n  for (let i = 0; i < 500; ++i) {\n    flocks[0].add(\n      new Particle(\n        0,\n        0,\n        7.5,\n        150,\n        FRAME1,\n        cycle1[csel],\n        0.0,\n        mx_coh,\n        10,\n        int(random(C1)),\n      ),\n    );\n  }\n\n  T_RED = [];\n  T_GREEN = [];\n  T_BLUE = [];\n  for (let i = 0; i < C4; ++i) {\n    POSX[i] = random(-W / 2, W / 2) + W / 2;\n    POSY[i] = random(-H / 2, H / 2) + H / 2;\n    T_RED.push(random(30, 220));\n    T_GREEN.push(random(30, 220));\n    T_BLUE.push(random(30, 220));\n  }\n\n  let cycle4 = [45, 90];\n  mx_coh = 0.6;\n  flocks.push(new Flock());\n  for (let i = 0; i < 500; ++i) {\n    let csel4 = int(random(2));\n    flocks[1].add(\n      new Particle(\n        2,\n        1,\n        1.5,\n        20,\n        FRAME4,\n        cycle4[csel4],\n        0.0,\n        mx_coh,\n        10,\n        int(random(C4)),\n      ),\n    );\n  }\n\n  let mode = 1;\n  if (mode == 1) {\n    for (let ii = 0; ii < 2; ++ii) {\n      let X2 = [];\n      let n_tree = int(random(6, 10));\n      let fdiv = 2;\n      if (ii == 1) {\n        n_tree = int((n_tree / 3) * 2);\n        fdiv = 2.5;\n      }\n      for (let i = 0; i < n_tree; ++i) {\n        X2.push(random(-W / fdiv, W / fdiv));\n      }\n      C02 = n_tree;\n      for (let i = 0; i < C02; ++i) {\n        POSX[i] = X2[i] + W / 2 + random(-15, 15);\n        POSY[i] = random(-H / 2, -H / 3) + H / 3 + (H / 6) * ii; //top\n      }\n\n      T_TYPE = [];\n      T_SPEED = [];\n      T_RAD = [];\n      T_MCOH = [];\n      T_ICOH = [];\n\n      T_RED = [];\n      T_GREEN = [];\n      T_BLUE = [];\n\n      OS_X = [];\n      OS_Y = [];\n\n      for (let i = 0; i < C02; ++i) {\n        T_TYPE.push(0); //int(random(2)));\n        T_RED.push(random(50, 200));\n        T_GREEN.push(random(50, 200));\n        T_BLUE.push(random(50, 200));\n\n        OS_X.push(random(-100, 100));\n        OS_Y.push(random(H / 3));\n      }\n\n      FRAME2 = 180;\n      let cycle1 = [180];\n      let csel1 = int(random(1));\n      mx_coh = 3;\n      flocks.push(new Flock());\n      for (let i = 0; i < 300; ++i) {\n        let speed = random(6, 12);\n        flocks[ii * 2 + 2].add(\n          new Particle(\n            1,\n            1,\n            speed,\n            20,\n            FRAME2,\n            cycle1[csel1],\n            0.5,\n            mx_coh,\n            ii * 10 + 15,\n            int(random(C02)),\n          ),\n        );\n      }\n\n      T_SPEED = [2.5, 2];\n      T_MCOH = [0.3, 1.0];\n      T_ICOH = [0.0, 0.0];\n      T_RAD = [20, 20];\n\n      FRAME3 = 180;\n      let cycle2 = [90, 180];\n\n      flocks.push(new Flock());\n      for (let i = 0; i < 500; ++i) {\n        let csel2 = int(random(2));\n        let tp_sel = int(random(C02));\n        let tp = T_TYPE[tp_sel];\n        flocks[ii * 2 + 3].add(\n          new Particle(\n            1,\n            2,\n            T_SPEED[tp],\n            T_RAD[tp],\n            FRAME3,\n            cycle2[csel2],\n            T_ICOH[tp],\n            T_MCOH[tp],\n            ii * 10 + 5,\n            tp_sel,\n          ),\n        );\n      }\n    }\n  }\n\n  //let X2 = random(-W/2, W/2) + W/2;\n  let Y2 = random(-H / 4, H / 2) + H / 2;\n  for (let i = 0; i < C2; ++i) {\n    POSX[i] = random(-W / 2, W / 2) + W / 2;\n    POSY[i] = random(-H / 4, H / 4) + Y2;\n  }\n}\n\nfunction draw() {\n  blendMode(BLEND);\n  background(BACK_COL);\n\n  if (frameCount < FRAME1) {\n    flocks[0].run();\n  } else if (frameCount < FRAME1 + FRAME4) {\n    flocks[1].run();\n  } else if (frameCount < FRAME1 + FRAME4 + FRAME2) {\n    flocks[2].run();\n  } else if (frameCount < FRAME1 + FRAME4 + FRAME2 + FRAME3) {\n    flocks[3].run();\n  } else if (frameCount < FRAME1 + FRAME4 + FRAME2 * 2 + FRAME3) {\n    flocks[4].run();\n  } else if (frameCount < FRAME1 + FRAME4 + FRAME2 * 2 + FRAME3 * 2) {\n    flocks[5].run();\n  }\n\n  image(G, 0, 0, width, height, 0, 0, W, H);\n}\n\nclass Flock {\n  particles;\n\n  constructor() {\n    this.particles = [];\n  }\n\n  add(particle) {\n    this.particles.push(particle);\n  }\n\n  run() {\n    this.update();\n    this.display();\n  }\n\n  update() {\n    for (let i = 0; i < this.particles.length; ++i) {\n      this.particles[i].update(this.particles);\n    }\n  }\n\n  display() {\n    for (let i = 0; i < this.particles.length; ++i) {\n      this.particles[i].display();\n    }\n  }\n}\n\nclass Particle {\n  acceleration;\n  velocity;\n  position;\n  radius;\n  max_r;\n  color;\n  col_sep;\n  maxforce = 1.0;\n  maxspeed = 2.5;\n  minspeed = 0.001;\n  mode;\n  base;\n  ali_f = 0.0;\n  coh_f = 0.0;\n  max_coh;\n  alpha;\n  fcnt;\n  cycle;\n  lcnt;\n  fin;\n\n  constructor(mode, base, speed, max_r, lcnt, cycle, coh, mxcoh, alpha, sel) {\n    this.acceleration = createVector(0, 0);\n\n    this.mode = mode;\n    this.base = base;\n    let offset_x;\n    let offset_y;\n\n    this.radius = 1;\n    this.alpha = alpha;\n\n    //let sel;\n    if (this.base == 0) {\n      this.maxspeed = speed;\n      this.col_sep = 0.5;\n      this.position = createVector(POSX[sel], POSY[sel]);\n      this.max_r = max_r;\n      this.velocity = createVector(random(-1, 1), random(-1, 1));\n    }\n    if (this.mode == 1) {\n      if (this.base == 1) {\n        offset_y = H / 2;\n        this.maxspeed = speed;\n        this.col_sep = 0.5;\n        this.position = createVector(\n          POSX[sel] + random(-5, 5),\n          POSY[sel] + offset_y,\n        );\n        this.max_r = max_r;\n        this.velocity = createVector(random(-1, 1), random(0.5, 1)); //;createVector(random(-1, 1), random(-1, 1));\n      } else if (this.base == 2) {\n        if (T_TYPE[sel] == 0) {\n          offset_y = random(H / 2);\n          this.maxspeed = speed * (offset_y / H) * (offset_y / H) * 5;\n          this.col_sep = 0.5;\n          this.position = createVector(POSX[sel], max(5, POSY[sel] + offset_y));\n          this.max_r = max_r + (offset_y / H) * 50;\n          this.velocity = createVector(random(-1, 1), random(0.1, 1));\n        } else {\n          offset_x = OS_X[sel];\n          offset_y = OS_Y[sel];\n          this.maxspeed = speed;\n          this.col_sep = 0.5;\n          this.position = createVector(\n            POSX[sel] + offset_x,\n            POSY[sel] + offset_y,\n          );\n          this.max_r = max_r;\n          this.velocity = createVector(random(-1, 1), random(-1, 1));\n        }\n      }\n    } else if (this.mode == 2) {\n      let ratio = POSY[sel] / H + 0.2;\n      this.maxspeed = speed * 1.2 * ratio;\n      this.radius = this.radius * 1.2 * ratio;\n      this.alpha = this.alpha * 1.2 * ratio;\n      if (this.base == 1) {\n        this.col_sep = 0.5;\n        this.position = createVector(POSX[sel], POSY[sel]);\n        this.max_r = max_r;\n        this.velocity = createVector(random(-1, 1), random(-1, 1));\n      }\n      // else if(this.base == 2){\n      //     this.col_sep = 0.5;\n      //     this.position = createVector(POSX[sel], POSY[sel]);\n      //     this.max_r = max_r;\n      //     this.velocity = createVector(random(-1, 1), random(-1, 1));\n      // }\n    }\n\n    //color\n    if (this.base == 0) {\n      this.color = createVector(\n        max(0, PRE_COL[ID[0]] + random(-50, 30)),\n        max(0, PRE_COL[ID[1]] + random(-50, 30)),\n        max(0, PRE_COL[ID[2]] + random(-50, 30)),\n      );\n    }\n    if (this.mode == 1) {\n      if (this.base == 1) {\n        this.color = createVector(\n          min(\n            255,\n            max(0, 200 - PRE_COL[ID[0]] + T_RED[sel] / 6 + random(-100, 0)),\n          ),\n          min(\n            255,\n            max(0, 200 - PRE_COL[ID[1]] + T_GREEN[sel] / 6 + random(-100, 0)),\n          ),\n          min(\n            255,\n            max(0, 200 - PRE_COL[ID[2]] + T_BLUE[sel] / 6 + random(-100, 0)),\n          ),\n        );\n      } else if (this.base == 2) {\n        this.color = createVector(\n          min(255, max(0, T_RED[sel] + random(-50, 50))),\n          min(255, max(0, T_GREEN[sel] + random(-50, 50))),\n          min(255, max(0, T_BLUE[sel] + random(-50, 50))),\n        );\n      }\n    } else if (this.mode == 2) {\n      if (this.base == 1) {\n        this.color = createVector(\n          min(255, max(0, T_RED[sel] + random(-30, 30))),\n          min(255, max(0, T_GREEN[sel] + random(-30, 30))),\n          min(255, max(0, T_BLUE[sel] + random(-30, 30))),\n        );\n      } else if (this.base == 2) {\n        this.color = createVector(\n          max(100, min(255, PRE_COL[ID[0]] + random(0, 100))),\n          max(100, min(255, PRE_COL[ID[1]] + random(0, 100))),\n          max(100, min(255, PRE_COL[ID[2]] + random(0, 100))),\n        );\n      }\n    }\n\n    this.ali_f = coh;\n    this.coh_f = coh;\n    this.max_coh = mxcoh;\n\n    this.fcnt = 0;\n    this.cycle = cycle;\n    this.fin = false;\n    this.lcnt = lcnt;\n  }\n\n  applyForce(force) {\n    this.acceleration.add(force);\n  }\n\n  inner_update(particles) {\n    let sep = this.separate(particles);\n    let ali = this.align(particles);\n    let coh = this.cohesion(particles);\n\n    sep.mult(1.5);\n    ali.mult(this.ali_f);\n    coh.mult(this.coh_f);\n\n    this.applyForce(sep);\n    this.applyForce(ali);\n    this.applyForce(coh);\n  }\n\n  update(particles) {\n    if (this.fcnt >= this.lcnt) {\n      this.fin = true;\n    }\n    if (this.fin) {\n      return;\n    }\n    this.inner_update(particles);\n\n    this.velocity.add(this.acceleration);\n    if (this.base == 0) {\n      if (this.fcnt < this.lcnt / 2) {\n        this.velocity.add(createVector(0, -0.1));\n      }\n    } else if (this.mode == 1 && this.base == 1) {\n      this.velocity.add(createVector(0.0, 0.2));\n    } else {\n      if (this.fcnt < this.lcnt / 2) {\n        this.velocity.add(createVector(-0.0, 0));\n      }\n    }\n\n    this.velocity.limit(this.maxspeed);\n    this.position.add(this.velocity);\n    this.border();\n    this.acceleration.mult(0);\n\n    this.radius = abs(sin((this.fcnt / this.cycle) * PI)) * this.max_r + 1;\n\n    if (this.base == 0) {\n      this.ali_f = min(1.0, this.ali_f + 0.05);\n      this.coh_f = min(this.max_coh, this.coh_f + 0.05);\n    } else if (this.mode == 1 && this.base == 1) {\n      this.ali_f = min(1.5, this.ali_f + 0.03);\n      this.coh_f = min(this.max_coh, this.coh_f + 0.05);\n    } else {\n      this.ali_f = min(0.7, this.ali_f + 0.1);\n      this.coh_f = min(this.max_coh, this.coh_f + 0.05);\n    }\n\n    if (this.fcnt < this.lcnt) {\n      this.fcnt += 1;\n    }\n  }\n\n  border() {\n    //if(this.base != 1 || this.mode != 1){\n    if (this.position.x > W) {\n      this.position.x -= W;\n    } else if (this.position.x < 0) {\n      this.position.x += W;\n    }\n    if ((this.base != 1 || this.mode != 1) && this.mode != 2) {\n      if (this.position.y > H) {\n        this.position.y -= H;\n      } else if (this.position.y < 0) {\n        this.position.y += H;\n      }\n    }\n  }\n\n  seek(target) {\n    let v = p5.Vector.sub(target, this.position);\n    v.normalize();\n    v.mult(this.maxspeed);\n    v.sub(this.velocity);\n    v.limit(this.maxforce);\n    return v;\n  }\n\n  separate(particles) {\n    let inter_range = 128.0;\n    let v = createVector(0, 0, 0);\n    for (let i = 0; i < particles.length; i++) {\n      let d = p5.Vector.dist(this.position, particles[i].position);\n      if (d <= 0) continue;\n\n      let col_diff = p5.Vector.sub(this.color, particles[i].color).mag() - 110;\n      if (d < inter_range + col_diff * this.col_sep) {\n        let diff = p5.Vector.sub(this.position, particles[i].position);\n        diff.normalize();\n        diff.div(d);\n        v.add(diff);\n      }\n    }\n\n    if (v.mag() > 0) {\n      v.normalize();\n      v.mult(this.maxspeed);\n      v.sub(this.velocity);\n      v.limit(this.maxforce);\n    }\n\n    return v;\n  }\n\n  align(particles) {\n    let inter_range = 128.0;\n    let v = createVector(0, 0, 0);\n    let count = 0;\n    for (let i = 0; i < particles.length; i++) {\n      let d = p5.Vector.dist(this.position, particles[i].position);\n      //let col_diff = abs(this.color - particles[i].color) - 128;\n      let col_diff = p5.Vector.sub(this.color, particles[i].color).mag() - 110;\n      if (d > 0 && d < inter_range - col_diff * this.col_sep) {\n        v.add(particles[i].velocity);\n        count++;\n      }\n    }\n    if (count > 0) {\n      v.div(count);\n      v.normalize();\n      v.mult(this.maxspeed);\n      v.sub(this.velocity);\n      v.limit(this.maxforce);\n      return v;\n    } else {\n      return createVector(0, 0, 0);\n    }\n  }\n\n  cohesion(particles) {\n    let neighbor_range = 128.0;\n    let v = createVector(0, 0, 0);\n    let count = 0;\n    for (let i = 0; i < particles.length; i++) {\n      let d = p5.Vector.dist(this.position, particles[i].position);\n\n      let col_diff = p5.Vector.sub(this.color, particles[i].color).mag() - 110;\n      if (d > 0 && d < neighbor_range - col_diff * this.col_sep) {\n        v.add(particles[i].position);\n\n        count++;\n      }\n    }\n    if (count > 0) {\n      v.div(count);\n      return this.seek(v);\n    } else {\n      return createVector(0, 0, 0);\n    }\n  }\n\n  display() {\n    if (this.fin) {\n      return;\n    }\n    let ratio = 1.0;\n    //if (this.base == 0){\n    //ratio = (H - this.position.y) / H * 1. + random(1.0);\n    ratio = 0.8 + random(0.5);\n    //}\n    if (this.base == 0) {\n      ratio = ratio * (3.0 - 3 * sqrt(this.position.y / H) * random(0.8, 1.2));\n    }\n    if (this.mode == 1 && this.base == 2) {\n      ratio = ratio + random(-0.2, 1);\n    }\n    G.strokeWeight(this.radius);\n    G.stroke(\n      this.color.x * ratio,\n      this.color.y * ratio,\n      this.color.z * ratio,\n      this.alpha,\n    );\n    G.point(this.position.x, this.position.y);\n  }\n}"
        },
        "audio": "https://res.cloudinary.com/cupcake-29k/video/upload/v1712905234/Audio/portal_audio_compassionate_intention_uniaec.mp3"
      }
    },
    "tags": ["db34d82a-4c48-4ddd-9de5-f562d8aa1bc9"],
    "link": "https://aware.29k.org/compassionateintention",
    "id": "13dfd5b5-f0af-4783-9fe1-3ba7773bcb89",
    "async": true,
    "description": "Aprende sobre a autocompaixão e como pode ser útil na tua vida.\n\nEncontra uma posição confortável e prepara-te para tomar algumas notas durante o exercício."
  },
  "es": {
    "description": "Aprende sobre la autocompasión y sobre cómo ésta puede ser útil en tu vida.",
    "introPortal": {
      "hostNotes": [
        {
          "text": "> Inicia la sesión cuando estés listo/a para comenzar"
        }
      ],
      "textColor": "#F9F8F4",
      "videoLoop": {
        "p5JsScript": {
          "lang": "javascript",
          "code": "let H;\nlet W;\n\nlet G;\n\nlet SEED;\n\nlet flocks = [];\nlet ID, ID2;\nlet PRE_COL;\n\nlet POSX = [];\nlet POSY = [];\nlet C1 = 7;\nlet C4 = 100;\nlet C02;\nlet C2 = 4;\n\nlet FRAME1 = 360; //360;\nlet FRAME2 = 180;\nlet FRAME3 = 180;\nlet FRAME4 = 90;\n\nlet BACK_COL;\n\nlet T_TYPE = [];\nlet T_SPEED = [];\nlet T_RAD = [];\nlet T_MCOH = [];\nlet T_ICOH = [];\n\nlet T_RED = [];\nlet T_GREEN = [];\nlet T_BLUE = [];\n\nlet OS_X = [];\nlet OS_Y = [];\n\nfunction setup() {\n  W = windowWidth;\n  H = windowHeight;\n  createCanvas(W, H);\n  G = createGraphics(W, H);\n\n  //SEED = fxrand()*998244353;\n  SEED = random() * 998244353;\n\n  randomSeed(SEED);\n  noiseSeed(SEED);\n\n  G.rectMode(CENTER);\n  G.noStroke();\n  let bsel = int(random(2));\n  let bcol = [60, 200];\n  BACK_COL = bcol[bsel];\n\n\n  ID = [0, 1, 2];\n  ID2 = [0, 1, 2];\n  shuffle(ID, true);\n  shuffle(ID2, true);\n\n  PRE_COL = [random(75) + 70, random(75) + 35, random(35)];\n\n  for (let i = 0; i < C1; i++) {\n    POSX[i] = random(-W / 3, W / 3) + W / 2;\n    POSY[i] = random(-H / 4, H / 2) + H / 2;\n  }\n\n  let cycle1 = [120, 180, 360];\n  let csel = int(random(3));\n  let mx_coh = 1.0; //random(1.3, 1.5);\n  flocks.push(new Flock());\n  for (let i = 0; i < 500; ++i) {\n    flocks[0].add(\n      new Particle(\n        0,\n        0,\n        7.5,\n        150,\n        FRAME1,\n        cycle1[csel],\n        0.0,\n        mx_coh,\n        10,\n        int(random(C1)),\n      ),\n    );\n  }\n\n  T_RED = [];\n  T_GREEN = [];\n  T_BLUE = [];\n  for (let i = 0; i < C4; ++i) {\n    POSX[i] = random(-W / 2, W / 2) + W / 2;\n    POSY[i] = random(-H / 2, H / 2) + H / 2;\n    T_RED.push(random(30, 220));\n    T_GREEN.push(random(30, 220));\n    T_BLUE.push(random(30, 220));\n  }\n\n  let cycle4 = [45, 90];\n  mx_coh = 0.6;\n  flocks.push(new Flock());\n  for (let i = 0; i < 500; ++i) {\n    let csel4 = int(random(2));\n    flocks[1].add(\n      new Particle(\n        2,\n        1,\n        1.5,\n        20,\n        FRAME4,\n        cycle4[csel4],\n        0.0,\n        mx_coh,\n        10,\n        int(random(C4)),\n      ),\n    );\n  }\n\n  let mode = 1;\n  if (mode == 1) {\n    for (let ii = 0; ii < 2; ++ii) {\n      let X2 = [];\n      let n_tree = int(random(6, 10));\n      let fdiv = 2;\n      if (ii == 1) {\n        n_tree = int((n_tree / 3) * 2);\n        fdiv = 2.5;\n      }\n      for (let i = 0; i < n_tree; ++i) {\n        X2.push(random(-W / fdiv, W / fdiv));\n      }\n      C02 = n_tree;\n      for (let i = 0; i < C02; ++i) {\n        POSX[i] = X2[i] + W / 2 + random(-15, 15);\n        POSY[i] = random(-H / 2, -H / 3) + H / 3 + (H / 6) * ii; //top\n      }\n\n      T_TYPE = [];\n      T_SPEED = [];\n      T_RAD = [];\n      T_MCOH = [];\n      T_ICOH = [];\n\n      T_RED = [];\n      T_GREEN = [];\n      T_BLUE = [];\n\n      OS_X = [];\n      OS_Y = [];\n\n      for (let i = 0; i < C02; ++i) {\n        T_TYPE.push(0); //int(random(2)));\n        T_RED.push(random(50, 200));\n        T_GREEN.push(random(50, 200));\n        T_BLUE.push(random(50, 200));\n\n        OS_X.push(random(-100, 100));\n        OS_Y.push(random(H / 3));\n      }\n\n      FRAME2 = 180;\n      let cycle1 = [180];\n      let csel1 = int(random(1));\n      mx_coh = 3;\n      flocks.push(new Flock());\n      for (let i = 0; i < 300; ++i) {\n        let speed = random(6, 12);\n        flocks[ii * 2 + 2].add(\n          new Particle(\n            1,\n            1,\n            speed,\n            20,\n            FRAME2,\n            cycle1[csel1],\n            0.5,\n            mx_coh,\n            ii * 10 + 15,\n            int(random(C02)),\n          ),\n        );\n      }\n\n      T_SPEED = [2.5, 2];\n      T_MCOH = [0.3, 1.0];\n      T_ICOH = [0.0, 0.0];\n      T_RAD = [20, 20];\n\n      FRAME3 = 180;\n      let cycle2 = [90, 180];\n\n      flocks.push(new Flock());\n      for (let i = 0; i < 500; ++i) {\n        let csel2 = int(random(2));\n        let tp_sel = int(random(C02));\n        let tp = T_TYPE[tp_sel];\n        flocks[ii * 2 + 3].add(\n          new Particle(\n            1,\n            2,\n            T_SPEED[tp],\n            T_RAD[tp],\n            FRAME3,\n            cycle2[csel2],\n            T_ICOH[tp],\n            T_MCOH[tp],\n            ii * 10 + 5,\n            tp_sel,\n          ),\n        );\n      }\n    }\n  }\n\n  //let X2 = random(-W/2, W/2) + W/2;\n  let Y2 = random(-H / 4, H / 2) + H / 2;\n  for (let i = 0; i < C2; ++i) {\n    POSX[i] = random(-W / 2, W / 2) + W / 2;\n    POSY[i] = random(-H / 4, H / 4) + Y2;\n  }\n}\n\nfunction draw() {\n  blendMode(BLEND);\n  background(BACK_COL);\n\n  if (frameCount < FRAME1) {\n    flocks[0].run();\n  } else if (frameCount < FRAME1 + FRAME4) {\n    flocks[1].run();\n  } else if (frameCount < FRAME1 + FRAME4 + FRAME2) {\n    flocks[2].run();\n  } else if (frameCount < FRAME1 + FRAME4 + FRAME2 + FRAME3) {\n    flocks[3].run();\n  } else if (frameCount < FRAME1 + FRAME4 + FRAME2 * 2 + FRAME3) {\n    flocks[4].run();\n  } else if (frameCount < FRAME1 + FRAME4 + FRAME2 * 2 + FRAME3 * 2) {\n    flocks[5].run();\n  }\n\n  image(G, 0, 0, width, height, 0, 0, W, H);\n}\n\nclass Flock {\n  particles;\n\n  constructor() {\n    this.particles = [];\n  }\n\n  add(particle) {\n    this.particles.push(particle);\n  }\n\n  run() {\n    this.update();\n    this.display();\n  }\n\n  update() {\n    for (let i = 0; i < this.particles.length; ++i) {\n      this.particles[i].update(this.particles);\n    }\n  }\n\n  display() {\n    for (let i = 0; i < this.particles.length; ++i) {\n      this.particles[i].display();\n    }\n  }\n}\n\nclass Particle {\n  acceleration;\n  velocity;\n  position;\n  radius;\n  max_r;\n  color;\n  col_sep;\n  maxforce = 1.0;\n  maxspeed = 2.5;\n  minspeed = 0.001;\n  mode;\n  base;\n  ali_f = 0.0;\n  coh_f = 0.0;\n  max_coh;\n  alpha;\n  fcnt;\n  cycle;\n  lcnt;\n  fin;\n\n  constructor(mode, base, speed, max_r, lcnt, cycle, coh, mxcoh, alpha, sel) {\n    this.acceleration = createVector(0, 0);\n\n    this.mode = mode;\n    this.base = base;\n    let offset_x;\n    let offset_y;\n\n    this.radius = 1;\n    this.alpha = alpha;\n\n    //let sel;\n    if (this.base == 0) {\n      this.maxspeed = speed;\n      this.col_sep = 0.5;\n      this.position = createVector(POSX[sel], POSY[sel]);\n      this.max_r = max_r;\n      this.velocity = createVector(random(-1, 1), random(-1, 1));\n    }\n    if (this.mode == 1) {\n      if (this.base == 1) {\n        offset_y = H / 2;\n        this.maxspeed = speed;\n        this.col_sep = 0.5;\n        this.position = createVector(\n          POSX[sel] + random(-5, 5),\n          POSY[sel] + offset_y,\n        );\n        this.max_r = max_r;\n        this.velocity = createVector(random(-1, 1), random(0.5, 1)); //;createVector(random(-1, 1), random(-1, 1));\n      } else if (this.base == 2) {\n        if (T_TYPE[sel] == 0) {\n          offset_y = random(H / 2);\n          this.maxspeed = speed * (offset_y / H) * (offset_y / H) * 5;\n          this.col_sep = 0.5;\n          this.position = createVector(POSX[sel], max(5, POSY[sel] + offset_y));\n          this.max_r = max_r + (offset_y / H) * 50;\n          this.velocity = createVector(random(-1, 1), random(0.1, 1));\n        } else {\n          offset_x = OS_X[sel];\n          offset_y = OS_Y[sel];\n          this.maxspeed = speed;\n          this.col_sep = 0.5;\n          this.position = createVector(\n            POSX[sel] + offset_x,\n            POSY[sel] + offset_y,\n          );\n          this.max_r = max_r;\n          this.velocity = createVector(random(-1, 1), random(-1, 1));\n        }\n      }\n    } else if (this.mode == 2) {\n      let ratio = POSY[sel] / H + 0.2;\n      this.maxspeed = speed * 1.2 * ratio;\n      this.radius = this.radius * 1.2 * ratio;\n      this.alpha = this.alpha * 1.2 * ratio;\n      if (this.base == 1) {\n        this.col_sep = 0.5;\n        this.position = createVector(POSX[sel], POSY[sel]);\n        this.max_r = max_r;\n        this.velocity = createVector(random(-1, 1), random(-1, 1));\n      }\n      // else if(this.base == 2){\n      //     this.col_sep = 0.5;\n      //     this.position = createVector(POSX[sel], POSY[sel]);\n      //     this.max_r = max_r;\n      //     this.velocity = createVector(random(-1, 1), random(-1, 1));\n      // }\n    }\n\n    //color\n    if (this.base == 0) {\n      this.color = createVector(\n        max(0, PRE_COL[ID[0]] + random(-50, 30)),\n        max(0, PRE_COL[ID[1]] + random(-50, 30)),\n        max(0, PRE_COL[ID[2]] + random(-50, 30)),\n      );\n    }\n    if (this.mode == 1) {\n      if (this.base == 1) {\n        this.color = createVector(\n          min(\n            255,\n            max(0, 200 - PRE_COL[ID[0]] + T_RED[sel] / 6 + random(-100, 0)),\n          ),\n          min(\n            255,\n            max(0, 200 - PRE_COL[ID[1]] + T_GREEN[sel] / 6 + random(-100, 0)),\n          ),\n          min(\n            255,\n            max(0, 200 - PRE_COL[ID[2]] + T_BLUE[sel] / 6 + random(-100, 0)),\n          ),\n        );\n      } else if (this.base == 2) {\n        this.color = createVector(\n          min(255, max(0, T_RED[sel] + random(-50, 50))),\n          min(255, max(0, T_GREEN[sel] + random(-50, 50))),\n          min(255, max(0, T_BLUE[sel] + random(-50, 50))),\n        );\n      }\n    } else if (this.mode == 2) {\n      if (this.base == 1) {\n        this.color = createVector(\n          min(255, max(0, T_RED[sel] + random(-30, 30))),\n          min(255, max(0, T_GREEN[sel] + random(-30, 30))),\n          min(255, max(0, T_BLUE[sel] + random(-30, 30))),\n        );\n      } else if (this.base == 2) {\n        this.color = createVector(\n          max(100, min(255, PRE_COL[ID[0]] + random(0, 100))),\n          max(100, min(255, PRE_COL[ID[1]] + random(0, 100))),\n          max(100, min(255, PRE_COL[ID[2]] + random(0, 100))),\n        );\n      }\n    }\n\n    this.ali_f = coh;\n    this.coh_f = coh;\n    this.max_coh = mxcoh;\n\n    this.fcnt = 0;\n    this.cycle = cycle;\n    this.fin = false;\n    this.lcnt = lcnt;\n  }\n\n  applyForce(force) {\n    this.acceleration.add(force);\n  }\n\n  inner_update(particles) {\n    let sep = this.separate(particles);\n    let ali = this.align(particles);\n    let coh = this.cohesion(particles);\n\n    sep.mult(1.5);\n    ali.mult(this.ali_f);\n    coh.mult(this.coh_f);\n\n    this.applyForce(sep);\n    this.applyForce(ali);\n    this.applyForce(coh);\n  }\n\n  update(particles) {\n    if (this.fcnt >= this.lcnt) {\n      this.fin = true;\n    }\n    if (this.fin) {\n      return;\n    }\n    this.inner_update(particles);\n\n    this.velocity.add(this.acceleration);\n    if (this.base == 0) {\n      if (this.fcnt < this.lcnt / 2) {\n        this.velocity.add(createVector(0, -0.1));\n      }\n    } else if (this.mode == 1 && this.base == 1) {\n      this.velocity.add(createVector(0.0, 0.2));\n    } else {\n      if (this.fcnt < this.lcnt / 2) {\n        this.velocity.add(createVector(-0.0, 0));\n      }\n    }\n\n    this.velocity.limit(this.maxspeed);\n    this.position.add(this.velocity);\n    this.border();\n    this.acceleration.mult(0);\n\n    this.radius = abs(sin((this.fcnt / this.cycle) * PI)) * this.max_r + 1;\n\n    if (this.base == 0) {\n      this.ali_f = min(1.0, this.ali_f + 0.05);\n      this.coh_f = min(this.max_coh, this.coh_f + 0.05);\n    } else if (this.mode == 1 && this.base == 1) {\n      this.ali_f = min(1.5, this.ali_f + 0.03);\n      this.coh_f = min(this.max_coh, this.coh_f + 0.05);\n    } else {\n      this.ali_f = min(0.7, this.ali_f + 0.1);\n      this.coh_f = min(this.max_coh, this.coh_f + 0.05);\n    }\n\n    if (this.fcnt < this.lcnt) {\n      this.fcnt += 1;\n    }\n  }\n\n  border() {\n    //if(this.base != 1 || this.mode != 1){\n    if (this.position.x > W) {\n      this.position.x -= W;\n    } else if (this.position.x < 0) {\n      this.position.x += W;\n    }\n    if ((this.base != 1 || this.mode != 1) && this.mode != 2) {\n      if (this.position.y > H) {\n        this.position.y -= H;\n      } else if (this.position.y < 0) {\n        this.position.y += H;\n      }\n    }\n  }\n\n  seek(target) {\n    let v = p5.Vector.sub(target, this.position);\n    v.normalize();\n    v.mult(this.maxspeed);\n    v.sub(this.velocity);\n    v.limit(this.maxforce);\n    return v;\n  }\n\n  separate(particles) {\n    let inter_range = 128.0;\n    let v = createVector(0, 0, 0);\n    for (let i = 0; i < particles.length; i++) {\n      let d = p5.Vector.dist(this.position, particles[i].position);\n      if (d <= 0) continue;\n\n      let col_diff = p5.Vector.sub(this.color, particles[i].color).mag() - 110;\n      if (d < inter_range + col_diff * this.col_sep) {\n        let diff = p5.Vector.sub(this.position, particles[i].position);\n        diff.normalize();\n        diff.div(d);\n        v.add(diff);\n      }\n    }\n\n    if (v.mag() > 0) {\n      v.normalize();\n      v.mult(this.maxspeed);\n      v.sub(this.velocity);\n      v.limit(this.maxforce);\n    }\n\n    return v;\n  }\n\n  align(particles) {\n    let inter_range = 128.0;\n    let v = createVector(0, 0, 0);\n    let count = 0;\n    for (let i = 0; i < particles.length; i++) {\n      let d = p5.Vector.dist(this.position, particles[i].position);\n      //let col_diff = abs(this.color - particles[i].color) - 128;\n      let col_diff = p5.Vector.sub(this.color, particles[i].color).mag() - 110;\n      if (d > 0 && d < inter_range - col_diff * this.col_sep) {\n        v.add(particles[i].velocity);\n        count++;\n      }\n    }\n    if (count > 0) {\n      v.div(count);\n      v.normalize();\n      v.mult(this.maxspeed);\n      v.sub(this.velocity);\n      v.limit(this.maxforce);\n      return v;\n    } else {\n      return createVector(0, 0, 0);\n    }\n  }\n\n  cohesion(particles) {\n    let neighbor_range = 128.0;\n    let v = createVector(0, 0, 0);\n    let count = 0;\n    for (let i = 0; i < particles.length; i++) {\n      let d = p5.Vector.dist(this.position, particles[i].position);\n\n      let col_diff = p5.Vector.sub(this.color, particles[i].color).mag() - 110;\n      if (d > 0 && d < neighbor_range - col_diff * this.col_sep) {\n        v.add(particles[i].position);\n\n        count++;\n      }\n    }\n    if (count > 0) {\n      v.div(count);\n      return this.seek(v);\n    } else {\n      return createVector(0, 0, 0);\n    }\n  }\n\n  display() {\n    if (this.fin) {\n      return;\n    }\n    let ratio = 1.0;\n    //if (this.base == 0){\n    //ratio = (H - this.position.y) / H * 1. + random(1.0);\n    ratio = 0.8 + random(0.5);\n    //}\n    if (this.base == 0) {\n      ratio = ratio * (3.0 - 3 * sqrt(this.position.y / H) * random(0.8, 1.2));\n    }\n    if (this.mode == 1 && this.base == 2) {\n      ratio = ratio + random(-0.2, 1);\n    }\n    G.strokeWeight(this.radius);\n    G.stroke(\n      this.color.x * ratio,\n      this.color.y * ratio,\n      this.color.z * ratio,\n      this.alpha,\n    );\n    G.point(this.position.x, this.position.y);\n  }\n}"
        },
        "audio": "https://res.cloudinary.com/cupcake-29k/video/upload/v1712905234/Audio/portal_audio_compassionate_intention_uniaec.mp3"
      }
    },
    "name": "Intención compasiva",
    "slides": [
      {
        "hostNotes": [
          {
            "text": "Bienvenidos/as. Soy X y hoy trabajaremos durante unos 30 minutos en la autocompasión.  \n\nHaremos un ejercicio en audio, seguido de un momento para reflexionar y compartir entre nosotros/as."
          },
          {
            "text": "Comencemos con un breve chequeo sobre cómo estamos. ¿Cómo te sientes en este momento? Por favor, responde en dos o tres palabras. X, ¿te gustaría empezar?\n\n> Permite que todos/as en la sesión, incluido tú, compartan uno a uno, una a una.\n\nGracias a todos/as por compartir. ¡Empecemos!"
          }
        ],
        "type": "host"
      },
      {
        "hostNotes": [
          {
            "text": "Encuentra una posición cómoda. Daré paso el ejercicio de audio y nos encontraremos de nuevo aquí cuando éste termine.\n\n> Pulsa play para comenzar el ejercicio"
          }
        ],
        "type": "content",
        "content": {
          "lottie": {
            "subtitles": "https://res.cloudinary.com/cupcake-29k/raw/upload/q_auto,t_global/v1745927436/Spanish/Subtitles%20SRT/Intencio%CC%81n_compasiva_jvc8fx.srt",
            "audio": "https://res.cloudinary.com/cupcake-29k/video/upload/v1744295652/Spanish/Audio%20MP3/Intencio%CC%81n_compasiva_oisb6x.mp3",
            "durationTimer": true,
            "source": "https://res.cloudinary.com/cupcake-29k/raw/upload/t_card_image/v1676977421/Lottie/audio_meditation_default_black_default_omemwt.json"
          }
        }
      },
      {
        "content": {
          "heading": "¿A dónde quieres llegar con la autocompasión?",
          "lottie": {
            "durationTimer": true,
            "duration": 60,
            "source": "https://res.cloudinary.com/cupcake-29k/raw/upload/t_card_image/v1676642915/Lottie/default_1min_black_rosi2l.json"
          }
        },
        "hostNotes": [
          {
            "text": "Ahora tomaremos 1 minuto para reflexionar por nuestra cuenta.  \n\n¿A dónde quieres llegar con la autocompasión?"
          },
          {
            "text": "Puedes tomar notas en un papel o mentalmente. No hay respuestas correctas o incorrectas, cada uno/a tiene sus propias respuestas. 1 minuto, empezando ahora.\n\n> Pulsa play para iniciar el temporizador.\n\nHa pasado 1 minuto, vamos a continuar."
          }
        ],
        "type": "reflection"
      },
      {
        "content": {
          "heading": "¿A dónde quieres llegar con la autocompasión?",
          "lottie": {
            "durationTimer": true,
            "duration": 120,
            "source": "https://res.cloudinary.com/cupcake-29k/raw/upload/t_card_image/v1676639253/Lottie/default_2min_black_o6egey.json"
          }
        },
        "hostNotes": [
          {
            "text": "Ahora entramos en la parte de compartir. Tenemos tres reglas para compartir:\n\n1. **Lo que se diga aquí, se queda aquí.**\n2. **Todo lo que necesitas hacer es escuchar.** No se necesita arreglar, ayudar ni dar consejos. Solo estamos presentes y explorando lo que nosotros/as mismos/as y los/las demás estamos experimentando."
          },
          {
            "text": "3. **Todo lo que sentimos dentro está bien.** Ira, amor, odio, tristeza. Lo que sea que surja. No hay correcto ni incorrecto. Simplemente es lo que es, hay lo que hay.\n\nSe establecerá un temporizador de 2 minutos como indicador. Si no deseas compartir, siempre puedes decir 'paso'."
          },
          {
            "text": "¿Quién le gustaría empezar?\n\n> Deja que todos/as (o los/las que tengas tiempo) compartan uno a uno, una a una. Pulsa play para iniciar el temporizador. Reinicia el temporizador para cada nueva intervención.\n\nMuchas gracias a todos/as."
          }
        ],
        "type": "sharing",
        "id": "Sharing 1"
      },
      {
        "hostNotes": [
          {
            "text": "Bien hecho. La autocompasión es un arte suave, se trata de ser amable y gentil con nosotros/as mismos/as. Si te animas, puedes continuar con esta práctica:\n\nDurante cinco días, pon una alarma en un momento aleatorio del día. Cuando esta suene, detente por un momento, considera tus necesidades, y haz algo amable contigo/a mismo/a antes de seguir adelante."
          },
          {
            "text": "Antes de salir de este espacio, hagamos una breve reflexión sobre qué ha cambiado.\n\n¿Cómo te sientes en este momento? ¿Ha cambiado algo? Por favor, responde en dos o tres palabras."
          },
          {
            "text": "¿Quién le gustaría empezar?\n\n> Deja que todos/as en la sesión compartan y/o se despidan uno por uno, una por una.\n\nGracias a todos/as por compartir y por uniros hoy a esta sesión.\n\n> Finaliza la sesión para enviar a todos/as a la experiencia de salida."
          }
        ],
        "type": "host"
      },
      {
        "content": {
          "heading": "Bien hecho",
          "text": "La autocompasión es un arte suave, que consiste en ser amable y gentil con nosotros/as mismos/as.\n\nSi te animas, puedes continuar con una práctica:\n\nDurante cinco días, pon una alarma en un momento aleatorio del día. Cuando esta suene, detente por un momento, considera tus necesidades, y haz algo amable contigo/a mismo/a antes de seguir adelante.",
          "image": {
            "source": "https://res.cloudinary.com/cupcake-29k/image/upload/q_auto,t_global/v1711547457/Images/card_Compassionate_intention_ub0tzl.png"
          }
        },
        "type": "instruction"
      }
    ],
    "liveDuration": 30,
    "theme": {
      "textColor": "#2E2E2E",
      "backgroundColor": "#55e069"
    },
    "hidden": false,
    "locked": false,
    "live": true,
    "published": true,
    "asyncDuration": 9,
    "card": {
      "image": {
        "source": "https://res.cloudinary.com/cupcake-29k/image/upload/t_card_image/v1711547457/Images/card_Compassionate_intention_ub0tzl.png"
      }
    },
    "coCreators": [
      {
        "name": "Jenny Rickardsson, script, editor",
        "url": "https://www.linkedin.com/in/jenny-rickardson-6770a959/?originalSubdomain=se",
        "image": "https://res.cloudinary.com/cupcake-29k/image/upload/t_cocreator_image/v1665413228/Contributors/Jenny%20Rickardsson.jpg"
      },
      {
        "name": "Kristin Neff & Chris Germer, original research",
        "url": "https://centerformsc.org/about/",
        "image": "https://res.cloudinary.com/cupcake-29k/image/upload/t_cocreator_image/v1697723039/Images/Germer%2C%20Neff.png"
      },
      {
        "name": "Raul Jimenez - voz en Español",
        "url": "https://www.linkedin.com/in/granraul75/",
        "image": ""
      },
      {
        "name": "tk87, artwork",
        "url": "https://openprocessing.org/user/332136?view=sketches&o=1",
        "image": "https://res.cloudinary.com/cupcake-29k/image/upload/t_cocreator_image/v1713964400/Images/user332136_oyt2dt.jpg"
      }
    ],
    "tags": ["db34d82a-4c48-4ddd-9de5-f562d8aa1bc9"],
    "link": "https://aware.29k.org/compassionateintention",
    "id": "13dfd5b5-f0af-4783-9fe1-3ba7773bcb89",
    "async": true
  },
  "cs": {
    "tags": ["db34d82a-4c48-4ddd-9de5-f562d8aa1bc9"],
    "asyncDuration": 9,
    "link": "https://aware.29k.org/compassionateintention",
    "id": "13dfd5b5-f0af-4783-9fe1-3ba7773bcb89"
  },
  "ja": {
    "liveDuration": 30,
    "slides": [
      {
        "type": "host",
        "hostNotes": [
          {
            "text": "Welcome. I am X and today we will work for around 30 minutes on xx\n\nWe’ll be doing xx ex. meditation followed by time for reflection and sharing with each other."
          },
          {
            "text": "Let’s start with a mini check-in. How are you feeling right now? Please answer in two-three words. X, would you like to start?\n\n> Let everyone in the session, including yourself, check in one by one.\n\nThank you all for checking in. Let’s get started."
          }
        ]
      },
      {
        "type": "content",
        "hostNotes": [
          {
            "text": "Find a comfortable position. I will start the audio exercise and we'll meet back here afterwards. \n\n> Push play to start the audio exercise"
          }
        ]
      },
      {
        "type": "reflection",
        "hostNotes": [
          {
            "text": "Now we’ll take 1 minute to reflect on our own.\n\nxxMain question\n\nxxFurther explanations of main question if needed"
          },
          {
            "text": "You can take notes on a piece of paper or just mental notes in your head. And there is no right or wrong here, our answers are our own. 1 minute starting now.\n\n> Press play to start the timer.\n\nThat’s 1 minute and it’s time to move on."
          }
        ]
      },
      {
        "type": "sharing",
        "hostNotes": [
          {
            "text": "Now we are getting into the sharing part. We have three rules for sharing:\n\n1. **What is said in here, stays in here.**\n2. **All you need to do is listen.** There is no fixing, helping or advice-giving needed. We are just showing up and exploring what ourselves and others are going through."
          },
          {
            "text": "3. **Everything on the inside is okay.** Anger, love, hatred, sadness. Whatever shows up. No wrongs, no rights. It is what it is.\n\nThere will be a timer set for 2 minutes as an indicator. If you don’t want to share you can always say ‘pass’."
          },
          {
            "text": "Who would like to start?\n\n> Let everyone (or as many as you got time for) share one by one. Press play to start the timer. Re-start for each new sharing.\n\nThank you so much everyone."
          }
        ],
        "id": "Sharing 1"
      },
      {
        "type": "host",
        "hostNotes": [
          {
            "text": "Well done. If you’re up for it, you can continue what we started here today with a mission to bring this into your everyday life.\n\nxx mission description"
          },
          {
            "text": "Before we leave this space let’s do a mini check-out. \n\nHow are you feeling right now? Has anything shifted? Please answer in two-three words."
          },
          {
            "text": "Who would like to start?\n\n> Let everyone in the session check out one by one.\n\nThank you all for checking out and for joining this session today.\n\n> Finish session to send everyone off to the exit experience."
          }
        ]
      },
      {
        "type": "instruction",
        "content": {
          "text": "Well done.\n\nSummary.\n\nIf you’re up for it, you can continue with this mission.\n\nmission description"
        }
      }
    ],
    "theme": {
      "textColor": "#2AE2D7"
    },
    "hidden": false,
    "locked": false,
    "live": true,
    "published": false,
    "asyncDuration": 9,
    "card": {},
    "introPortal": {
      "textColor": "#2AE2D7",
      "hostNotes": [
        {
          "text": "> Start the session when you're ready to go"
        }
      ]
    },
    "tags": ["db34d82a-4c48-4ddd-9de5-f562d8aa1bc9"],
    "link": "https://aware.29k.org/compassionateintention",
    "id": "13dfd5b5-f0af-4783-9fe1-3ba7773bcb89",
    "async": false
  },
  "pt-BR": {
    "liveDuration": 30,
    "slides": [
      {
        "hostNotes": [
          {
            "text": "Bem-vindos. Eu sou X e hoje vamos trabalhar por cerca de 30 minutos o tema da autocompaixão.\n\nFaremos um exercício em áudio, seguido de um tempo para reflexão e compartilhamento entre nós."
          },
          {
            "text": "Vamos começar com um mini check-in. Como você está se sentindo agora? Por favor, responda em duas ou três palavras. X, você gostaria de começar?\n\n> Deixe todos na sessão, inclusive você, fazerem o check-in um por um.\n\nObrigado a todos por compartilharem. Vamos começar."
          }
        ],
        "type": "host"
      },
      {
        "hostNotes": [
          {
            "text": "Encontre uma posição confortável. Vou iniciar o exercício em áudio e nos encontraremos aqui novamente depois.\n\n> Aperte play para começar o exercício em áudio."
          }
        ],
        "type": "content",
        "content": {
          "lottie": {
            "subtitles": "https://res.cloudinary.com/cupcake-29k/raw/upload/v1710426301/SRT%20%28captions%29%20files/Compassionate_intention_q45eop.srt",
            "audio": "https://res.cloudinary.com/cupcake-29k/video/upload/v1710426353/Audio/Compassionate_intention_svuq74.mp3",
            "durationTimer": true,
            "source": "https://res.cloudinary.com/cupcake-29k/raw/upload/t_card_image/v1676977421/Lottie/audio_meditation_default_black_default_omemwt.json"
          }
        }
      },
      {
        "content": {
          "heading": "Para onde você quer ir com a autocompaixão?",
          "lottie": {
            "durationTimer": true,
            "duration": 60,
            "source": "https://res.cloudinary.com/cupcake-29k/raw/upload/t_card_image/v1676642915/Lottie/default_1min_black_rosi2l.json"
          }
        },
        "hostNotes": [
          {
            "text": "Agora vamos tirar 1 minuto para refletir individualmente.\n\nPara onde você quer ir com a autocompaixão?"
          },
          {
            "text": "Você pode fazer anotações em um papel ou apenas mentalmente. Não existe certo ou errado aqui, nossas respostas são pessoais. 1 minuto começando agora.\n\n> Aperte play para iniciar o cronômetro.\n\nPassou 1 minuto, é hora de seguir em frente."
          }
        ],
        "type": "reflection"
      },
      {
        "content": {
          "heading": "Para onde você quer ir com a autocompaixão?",
          "lottie": {
            "durationTimer": true,
            "duration": 120,
            "source": "https://res.cloudinary.com/cupcake-29k/raw/upload/t_card_image/v1676639253/Lottie/default_2min_black_o6egey.json"
          }
        },
        "hostNotes": [
          {
            "text": "Agora estamos entrando na parte de compartilhamento. Temos três regras para o compartilhamento:\n\n1. **O que é dito aqui, fica aqui.**\n2. **Tudo o que você precisa fazer é ouvir.** Não é necessário consertar, ajudar ou dar conselhos. Estamos apenas presentes e explorando o que nós e os outros estamos vivenciando."
          },
          {
            "text": "3. **Tudo o que você sentir é válido.** Raiva, amor, ódio, tristeza. O que surgir. Não existe certo ou errado. \n\nO cronômetro será ajustado para 2 minutos como referência. Se você não quiser compartilhar, pode simplesmente dizer “passo”.\n\n"
          },
          {
            "text": "Quem gostaria de começar?\n\n> Deixe todos (ou o maior número possível, conforme o tempo permitir) compartilharem um por um. Aperte play para iniciar o cronômetro. Reinicie para cada novo compartilhamento.\n\nMuito obrigado a todos.\n\n"
          }
        ],
        "type": "sharing",
        "id": "Sharing 1"
      },
      {
        "hostNotes": [
          {
            "text": "Muito bem. A autocompaixão é uma arte suave, trata-se de sermos gentis e cuidadosos conosco. Se quiser, você pode continuar com esta sugestão:\n\nPrograme um lembrete em um horário aleatório do dia, durante cinco dias. Quando ele tocar, pare, considere suas necessidades por um momento e faça algo gentil por você antes de seguir em frente."
          },
          {
            "text": "Antes de sairmos deste espaço, vamos fazer um mini check-out.\n\nComo você está se sentindo agora? Algo mudou? Por favor, responda em duas ou três palavras."
          },
          {
            "text": "Quem gostaria de começar?\n\n> Deixe todos (ou o maior número possível, conforme o tempo permitir) compartilharem um por um. Aperte play para iniciar o cronômetro. Reinicie para cada novo compartilhamento.\n\nMuito obrigado a todos.\n\n"
          }
        ],
        "type": "host"
      },
      {
        "content": {
          "heading": "Muito bem",
          "text": "A autocompaixão é uma arte suave; trata-se de sermos gentis e cuidadosos conosco.\n\nSe quiser, você pode continuar com uma sugestão:\n\nPrograme um lembrete em um horário aleatório do dia, durante cinco dias. Quando ele tocar, pare, considere suas necessidades por um momento e faça algo gentil por você antes de seguir em frente",
          "image": {
            "source": "https://res.cloudinary.com/cupcake-29k/image/upload/q_auto,t_global/v1711547457/Images/card_Compassionate_intention_ub0tzl.png"
          }
        },
        "type": "instruction"
      }
    ],
    "theme": {
      "textColor": "#2E2E2E",
      "backgroundColor": "#55e069"
    },
    "hidden": false,
    "locked": false,
    "name": "Intenção compassiva",
    "live": true,
    "published": false,
    "asyncDuration": 9,
    "card": {
      "image": {
        "source": "https://res.cloudinary.com/cupcake-29k/image/upload/t_card_image/v1711547457/Images/card_Compassionate_intention_ub0tzl.png"
      }
    },
    "coCreators": [
      {
        "name": "Jenny Rickardsson, script, editor",
        "url": "https://www.linkedin.com/in/jenny-rickardson-6770a959/?originalSubdomain=se",
        "image": "https://res.cloudinary.com/cupcake-29k/image/upload/t_cocreator_image/v1665413228/Contributors/Jenny%20Rickardsson.jpg"
      },
      {
        "name": "Kristin Neff & Chris Germer, original research",
        "url": "https://centerformsc.org/about/",
        "image": "https://res.cloudinary.com/cupcake-29k/image/upload/t_cocreator_image/v1697723039/Images/Germer%2C%20Neff.png"
      },
      {
        "name": "Tabitha, AI-generated voice",
        "url": "https://www.descript.com/ai-voices",
        "image": "https://res.cloudinary.com/cupcake-29k/image/upload/t_cocreator_image/v1710239861/Contributors/descript_ps0olu.webp"
      },
      {
        "name": "tk87, artwork",
        "url": "https://openprocessing.org/user/332136?view=sketches&o=1",
        "image": "https://res.cloudinary.com/cupcake-29k/image/upload/t_cocreator_image/v1713964400/Images/user332136_oyt2dt.jpg"
      }
    ],
    "introPortal": {
      "hostNotes": [
        {
          "text": ">Comece a sessão quando estiver pronto para seguir"
        }
      ],
      "textColor": "#F9F8F4",
      "videoLoop": {
        "p5JsScript": {
          "lang": "javascript",
          "code": "let H;\nlet W;\n\nlet G;\n\nlet SEED;\n\nlet flocks = [];\nlet ID, ID2;\nlet PRE_COL;\n\nlet POSX = [];\nlet POSY = [];\nlet C1 = 7;\nlet C4 = 100;\nlet C02;\nlet C2 = 4;\n\nlet FRAME1 = 360; //360;\nlet FRAME2 = 180;\nlet FRAME3 = 180;\nlet FRAME4 = 90;\n\nlet BACK_COL;\n\nlet T_TYPE = [];\nlet T_SPEED = [];\nlet T_RAD = [];\nlet T_MCOH = [];\nlet T_ICOH = [];\n\nlet T_RED = [];\nlet T_GREEN = [];\nlet T_BLUE = [];\n\nlet OS_X = [];\nlet OS_Y = [];\n\nfunction setup() {\n  W = windowWidth;\n  H = windowHeight;\n  createCanvas(W, H);\n  G = createGraphics(W, H);\n\n  //SEED = fxrand()*998244353;\n  SEED = random() * 998244353;\n\n  randomSeed(SEED);\n  noiseSeed(SEED);\n\n  G.rectMode(CENTER);\n  G.noStroke();\n  let bsel = int(random(2));\n  let bcol = [60, 200];\n  BACK_COL = bcol[bsel];\n\n\n  ID = [0, 1, 2];\n  ID2 = [0, 1, 2];\n  shuffle(ID, true);\n  shuffle(ID2, true);\n\n  PRE_COL = [random(75) + 70, random(75) + 35, random(35)];\n\n  for (let i = 0; i < C1; i++) {\n    POSX[i] = random(-W / 3, W / 3) + W / 2;\n    POSY[i] = random(-H / 4, H / 2) + H / 2;\n  }\n\n  let cycle1 = [120, 180, 360];\n  let csel = int(random(3));\n  let mx_coh = 1.0; //random(1.3, 1.5);\n  flocks.push(new Flock());\n  for (let i = 0; i < 500; ++i) {\n    flocks[0].add(\n      new Particle(\n        0,\n        0,\n        7.5,\n        150,\n        FRAME1,\n        cycle1[csel],\n        0.0,\n        mx_coh,\n        10,\n        int(random(C1)),\n      ),\n    );\n  }\n\n  T_RED = [];\n  T_GREEN = [];\n  T_BLUE = [];\n  for (let i = 0; i < C4; ++i) {\n    POSX[i] = random(-W / 2, W / 2) + W / 2;\n    POSY[i] = random(-H / 2, H / 2) + H / 2;\n    T_RED.push(random(30, 220));\n    T_GREEN.push(random(30, 220));\n    T_BLUE.push(random(30, 220));\n  }\n\n  let cycle4 = [45, 90];\n  mx_coh = 0.6;\n  flocks.push(new Flock());\n  for (let i = 0; i < 500; ++i) {\n    let csel4 = int(random(2));\n    flocks[1].add(\n      new Particle(\n        2,\n        1,\n        1.5,\n        20,\n        FRAME4,\n        cycle4[csel4],\n        0.0,\n        mx_coh,\n        10,\n        int(random(C4)),\n      ),\n    );\n  }\n\n  let mode = 1;\n  if (mode == 1) {\n    for (let ii = 0; ii < 2; ++ii) {\n      let X2 = [];\n      let n_tree = int(random(6, 10));\n      let fdiv = 2;\n      if (ii == 1) {\n        n_tree = int((n_tree / 3) * 2);\n        fdiv = 2.5;\n      }\n      for (let i = 0; i < n_tree; ++i) {\n        X2.push(random(-W / fdiv, W / fdiv));\n      }\n      C02 = n_tree;\n      for (let i = 0; i < C02; ++i) {\n        POSX[i] = X2[i] + W / 2 + random(-15, 15);\n        POSY[i] = random(-H / 2, -H / 3) + H / 3 + (H / 6) * ii; //top\n      }\n\n      T_TYPE = [];\n      T_SPEED = [];\n      T_RAD = [];\n      T_MCOH = [];\n      T_ICOH = [];\n\n      T_RED = [];\n      T_GREEN = [];\n      T_BLUE = [];\n\n      OS_X = [];\n      OS_Y = [];\n\n      for (let i = 0; i < C02; ++i) {\n        T_TYPE.push(0); //int(random(2)));\n        T_RED.push(random(50, 200));\n        T_GREEN.push(random(50, 200));\n        T_BLUE.push(random(50, 200));\n\n        OS_X.push(random(-100, 100));\n        OS_Y.push(random(H / 3));\n      }\n\n      FRAME2 = 180;\n      let cycle1 = [180];\n      let csel1 = int(random(1));\n      mx_coh = 3;\n      flocks.push(new Flock());\n      for (let i = 0; i < 300; ++i) {\n        let speed = random(6, 12);\n        flocks[ii * 2 + 2].add(\n          new Particle(\n            1,\n            1,\n            speed,\n            20,\n            FRAME2,\n            cycle1[csel1],\n            0.5,\n            mx_coh,\n            ii * 10 + 15,\n            int(random(C02)),\n          ),\n        );\n      }\n\n      T_SPEED = [2.5, 2];\n      T_MCOH = [0.3, 1.0];\n      T_ICOH = [0.0, 0.0];\n      T_RAD = [20, 20];\n\n      FRAME3 = 180;\n      let cycle2 = [90, 180];\n\n      flocks.push(new Flock());\n      for (let i = 0; i < 500; ++i) {\n        let csel2 = int(random(2));\n        let tp_sel = int(random(C02));\n        let tp = T_TYPE[tp_sel];\n        flocks[ii * 2 + 3].add(\n          new Particle(\n            1,\n            2,\n            T_SPEED[tp],\n            T_RAD[tp],\n            FRAME3,\n            cycle2[csel2],\n            T_ICOH[tp],\n            T_MCOH[tp],\n            ii * 10 + 5,\n            tp_sel,\n          ),\n        );\n      }\n    }\n  }\n\n  //let X2 = random(-W/2, W/2) + W/2;\n  let Y2 = random(-H / 4, H / 2) + H / 2;\n  for (let i = 0; i < C2; ++i) {\n    POSX[i] = random(-W / 2, W / 2) + W / 2;\n    POSY[i] = random(-H / 4, H / 4) + Y2;\n  }\n}\n\nfunction draw() {\n  blendMode(BLEND);\n  background(BACK_COL);\n\n  if (frameCount < FRAME1) {\n    flocks[0].run();\n  } else if (frameCount < FRAME1 + FRAME4) {\n    flocks[1].run();\n  } else if (frameCount < FRAME1 + FRAME4 + FRAME2) {\n    flocks[2].run();\n  } else if (frameCount < FRAME1 + FRAME4 + FRAME2 + FRAME3) {\n    flocks[3].run();\n  } else if (frameCount < FRAME1 + FRAME4 + FRAME2 * 2 + FRAME3) {\n    flocks[4].run();\n  } else if (frameCount < FRAME1 + FRAME4 + FRAME2 * 2 + FRAME3 * 2) {\n    flocks[5].run();\n  }\n\n  image(G, 0, 0, width, height, 0, 0, W, H);\n}\n\nclass Flock {\n  particles;\n\n  constructor() {\n    this.particles = [];\n  }\n\n  add(particle) {\n    this.particles.push(particle);\n  }\n\n  run() {\n    this.update();\n    this.display();\n  }\n\n  update() {\n    for (let i = 0; i < this.particles.length; ++i) {\n      this.particles[i].update(this.particles);\n    }\n  }\n\n  display() {\n    for (let i = 0; i < this.particles.length; ++i) {\n      this.particles[i].display();\n    }\n  }\n}\n\nclass Particle {\n  acceleration;\n  velocity;\n  position;\n  radius;\n  max_r;\n  color;\n  col_sep;\n  maxforce = 1.0;\n  maxspeed = 2.5;\n  minspeed = 0.001;\n  mode;\n  base;\n  ali_f = 0.0;\n  coh_f = 0.0;\n  max_coh;\n  alpha;\n  fcnt;\n  cycle;\n  lcnt;\n  fin;\n\n  constructor(mode, base, speed, max_r, lcnt, cycle, coh, mxcoh, alpha, sel) {\n    this.acceleration = createVector(0, 0);\n\n    this.mode = mode;\n    this.base = base;\n    let offset_x;\n    let offset_y;\n\n    this.radius = 1;\n    this.alpha = alpha;\n\n    //let sel;\n    if (this.base == 0) {\n      this.maxspeed = speed;\n      this.col_sep = 0.5;\n      this.position = createVector(POSX[sel], POSY[sel]);\n      this.max_r = max_r;\n      this.velocity = createVector(random(-1, 1), random(-1, 1));\n    }\n    if (this.mode == 1) {\n      if (this.base == 1) {\n        offset_y = H / 2;\n        this.maxspeed = speed;\n        this.col_sep = 0.5;\n        this.position = createVector(\n          POSX[sel] + random(-5, 5),\n          POSY[sel] + offset_y,\n        );\n        this.max_r = max_r;\n        this.velocity = createVector(random(-1, 1), random(0.5, 1)); //;createVector(random(-1, 1), random(-1, 1));\n      } else if (this.base == 2) {\n        if (T_TYPE[sel] == 0) {\n          offset_y = random(H / 2);\n          this.maxspeed = speed * (offset_y / H) * (offset_y / H) * 5;\n          this.col_sep = 0.5;\n          this.position = createVector(POSX[sel], max(5, POSY[sel] + offset_y));\n          this.max_r = max_r + (offset_y / H) * 50;\n          this.velocity = createVector(random(-1, 1), random(0.1, 1));\n        } else {\n          offset_x = OS_X[sel];\n          offset_y = OS_Y[sel];\n          this.maxspeed = speed;\n          this.col_sep = 0.5;\n          this.position = createVector(\n            POSX[sel] + offset_x,\n            POSY[sel] + offset_y,\n          );\n          this.max_r = max_r;\n          this.velocity = createVector(random(-1, 1), random(-1, 1));\n        }\n      }\n    } else if (this.mode == 2) {\n      let ratio = POSY[sel] / H + 0.2;\n      this.maxspeed = speed * 1.2 * ratio;\n      this.radius = this.radius * 1.2 * ratio;\n      this.alpha = this.alpha * 1.2 * ratio;\n      if (this.base == 1) {\n        this.col_sep = 0.5;\n        this.position = createVector(POSX[sel], POSY[sel]);\n        this.max_r = max_r;\n        this.velocity = createVector(random(-1, 1), random(-1, 1));\n      }\n      // else if(this.base == 2){\n      //     this.col_sep = 0.5;\n      //     this.position = createVector(POSX[sel], POSY[sel]);\n      //     this.max_r = max_r;\n      //     this.velocity = createVector(random(-1, 1), random(-1, 1));\n      // }\n    }\n\n    //color\n    if (this.base == 0) {\n      this.color = createVector(\n        max(0, PRE_COL[ID[0]] + random(-50, 30)),\n        max(0, PRE_COL[ID[1]] + random(-50, 30)),\n        max(0, PRE_COL[ID[2]] + random(-50, 30)),\n      );\n    }\n    if (this.mode == 1) {\n      if (this.base == 1) {\n        this.color = createVector(\n          min(\n            255,\n            max(0, 200 - PRE_COL[ID[0]] + T_RED[sel] / 6 + random(-100, 0)),\n          ),\n          min(\n            255,\n            max(0, 200 - PRE_COL[ID[1]] + T_GREEN[sel] / 6 + random(-100, 0)),\n          ),\n          min(\n            255,\n            max(0, 200 - PRE_COL[ID[2]] + T_BLUE[sel] / 6 + random(-100, 0)),\n          ),\n        );\n      } else if (this.base == 2) {\n        this.color = createVector(\n          min(255, max(0, T_RED[sel] + random(-50, 50))),\n          min(255, max(0, T_GREEN[sel] + random(-50, 50))),\n          min(255, max(0, T_BLUE[sel] + random(-50, 50))),\n        );\n      }\n    } else if (this.mode == 2) {\n      if (this.base == 1) {\n        this.color = createVector(\n          min(255, max(0, T_RED[sel] + random(-30, 30))),\n          min(255, max(0, T_GREEN[sel] + random(-30, 30))),\n          min(255, max(0, T_BLUE[sel] + random(-30, 30))),\n        );\n      } else if (this.base == 2) {\n        this.color = createVector(\n          max(100, min(255, PRE_COL[ID[0]] + random(0, 100))),\n          max(100, min(255, PRE_COL[ID[1]] + random(0, 100))),\n          max(100, min(255, PRE_COL[ID[2]] + random(0, 100))),\n        );\n      }\n    }\n\n    this.ali_f = coh;\n    this.coh_f = coh;\n    this.max_coh = mxcoh;\n\n    this.fcnt = 0;\n    this.cycle = cycle;\n    this.fin = false;\n    this.lcnt = lcnt;\n  }\n\n  applyForce(force) {\n    this.acceleration.add(force);\n  }\n\n  inner_update(particles) {\n    let sep = this.separate(particles);\n    let ali = this.align(particles);\n    let coh = this.cohesion(particles);\n\n    sep.mult(1.5);\n    ali.mult(this.ali_f);\n    coh.mult(this.coh_f);\n\n    this.applyForce(sep);\n    this.applyForce(ali);\n    this.applyForce(coh);\n  }\n\n  update(particles) {\n    if (this.fcnt >= this.lcnt) {\n      this.fin = true;\n    }\n    if (this.fin) {\n      return;\n    }\n    this.inner_update(particles);\n\n    this.velocity.add(this.acceleration);\n    if (this.base == 0) {\n      if (this.fcnt < this.lcnt / 2) {\n        this.velocity.add(createVector(0, -0.1));\n      }\n    } else if (this.mode == 1 && this.base == 1) {\n      this.velocity.add(createVector(0.0, 0.2));\n    } else {\n      if (this.fcnt < this.lcnt / 2) {\n        this.velocity.add(createVector(-0.0, 0));\n      }\n    }\n\n    this.velocity.limit(this.maxspeed);\n    this.position.add(this.velocity);\n    this.border();\n    this.acceleration.mult(0);\n\n    this.radius = abs(sin((this.fcnt / this.cycle) * PI)) * this.max_r + 1;\n\n    if (this.base == 0) {\n      this.ali_f = min(1.0, this.ali_f + 0.05);\n      this.coh_f = min(this.max_coh, this.coh_f + 0.05);\n    } else if (this.mode == 1 && this.base == 1) {\n      this.ali_f = min(1.5, this.ali_f + 0.03);\n      this.coh_f = min(this.max_coh, this.coh_f + 0.05);\n    } else {\n      this.ali_f = min(0.7, this.ali_f + 0.1);\n      this.coh_f = min(this.max_coh, this.coh_f + 0.05);\n    }\n\n    if (this.fcnt < this.lcnt) {\n      this.fcnt += 1;\n    }\n  }\n\n  border() {\n    //if(this.base != 1 || this.mode != 1){\n    if (this.position.x > W) {\n      this.position.x -= W;\n    } else if (this.position.x < 0) {\n      this.position.x += W;\n    }\n    if ((this.base != 1 || this.mode != 1) && this.mode != 2) {\n      if (this.position.y > H) {\n        this.position.y -= H;\n      } else if (this.position.y < 0) {\n        this.position.y += H;\n      }\n    }\n  }\n\n  seek(target) {\n    let v = p5.Vector.sub(target, this.position);\n    v.normalize();\n    v.mult(this.maxspeed);\n    v.sub(this.velocity);\n    v.limit(this.maxforce);\n    return v;\n  }\n\n  separate(particles) {\n    let inter_range = 128.0;\n    let v = createVector(0, 0, 0);\n    for (let i = 0; i < particles.length; i++) {\n      let d = p5.Vector.dist(this.position, particles[i].position);\n      if (d <= 0) continue;\n\n      let col_diff = p5.Vector.sub(this.color, particles[i].color).mag() - 110;\n      if (d < inter_range + col_diff * this.col_sep) {\n        let diff = p5.Vector.sub(this.position, particles[i].position);\n        diff.normalize();\n        diff.div(d);\n        v.add(diff);\n      }\n    }\n\n    if (v.mag() > 0) {\n      v.normalize();\n      v.mult(this.maxspeed);\n      v.sub(this.velocity);\n      v.limit(this.maxforce);\n    }\n\n    return v;\n  }\n\n  align(particles) {\n    let inter_range = 128.0;\n    let v = createVector(0, 0, 0);\n    let count = 0;\n    for (let i = 0; i < particles.length; i++) {\n      let d = p5.Vector.dist(this.position, particles[i].position);\n      //let col_diff = abs(this.color - particles[i].color) - 128;\n      let col_diff = p5.Vector.sub(this.color, particles[i].color).mag() - 110;\n      if (d > 0 && d < inter_range - col_diff * this.col_sep) {\n        v.add(particles[i].velocity);\n        count++;\n      }\n    }\n    if (count > 0) {\n      v.div(count);\n      v.normalize();\n      v.mult(this.maxspeed);\n      v.sub(this.velocity);\n      v.limit(this.maxforce);\n      return v;\n    } else {\n      return createVector(0, 0, 0);\n    }\n  }\n\n  cohesion(particles) {\n    let neighbor_range = 128.0;\n    let v = createVector(0, 0, 0);\n    let count = 0;\n    for (let i = 0; i < particles.length; i++) {\n      let d = p5.Vector.dist(this.position, particles[i].position);\n\n      let col_diff = p5.Vector.sub(this.color, particles[i].color).mag() - 110;\n      if (d > 0 && d < neighbor_range - col_diff * this.col_sep) {\n        v.add(particles[i].position);\n\n        count++;\n      }\n    }\n    if (count > 0) {\n      v.div(count);\n      return this.seek(v);\n    } else {\n      return createVector(0, 0, 0);\n    }\n  }\n\n  display() {\n    if (this.fin) {\n      return;\n    }\n    let ratio = 1.0;\n    //if (this.base == 0){\n    //ratio = (H - this.position.y) / H * 1. + random(1.0);\n    ratio = 0.8 + random(0.5);\n    //}\n    if (this.base == 0) {\n      ratio = ratio * (3.0 - 3 * sqrt(this.position.y / H) * random(0.8, 1.2));\n    }\n    if (this.mode == 1 && this.base == 2) {\n      ratio = ratio + random(-0.2, 1);\n    }\n    G.strokeWeight(this.radius);\n    G.stroke(\n      this.color.x * ratio,\n      this.color.y * ratio,\n      this.color.z * ratio,\n      this.alpha,\n    );\n    G.point(this.position.x, this.position.y);\n  }\n}"
        },
        "audio": "https://res.cloudinary.com/cupcake-29k/video/upload/v1712905234/Audio/portal_audio_compassionate_intention_uniaec.mp3"
      }
    },
    "tags": ["db34d82a-4c48-4ddd-9de5-f562d8aa1bc9"],
    "link": "https://aware.29k.org/compassionateintention",
    "id": "13dfd5b5-f0af-4783-9fe1-3ba7773bcb89",
    "async": true,
    "description": "Aprenda sobre autocompaixão e como ela pode ser útil em sua vida."
  },
  "da": {
    "tags": ["db34d82a-4c48-4ddd-9de5-f562d8aa1bc9"],
    "asyncDuration": 9,
    "link": "https://aware.29k.org/compassionateintention",
    "id": "13dfd5b5-f0af-4783-9fe1-3ba7773bcb89"
  },
  "nl": {
    "tags": ["db34d82a-4c48-4ddd-9de5-f562d8aa1bc9"],
    "asyncDuration": 9,
    "link": "https://aware.29k.org/compassionateintention",
    "id": "13dfd5b5-f0af-4783-9fe1-3ba7773bcb89"
  }
}
